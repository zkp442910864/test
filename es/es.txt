ES6:

  ES6 声明变量的六种方法
    ES5 只有两种声明变量的方法：var命令和function命令。
    ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。
    所以，ES6 一共有 6 种声明变量的方法。

  let 和 const 命令
    http://es6.ruanyifeng.com/#docs/let#const-命令
    1.let 命令
      let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
      不存在变量提升
      暂时性死区
      不允许重复声明

    2.块级作用域
      {} 相当于 (function(){})()
      在块作用域里声明函数用 函数表达式 声明
        如： let f = function () {
              return a;
            };

    3.const 命令
      声明一个只读的常量。一旦声明，常量的值就不能改变。
      普通的值可以保证不变，但是对象和数组只能保证指向内存的指针不变
      如果想将对象完全冻结就用到 Object.freeze({})
      除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。
        var constantize = (obj) => {
          Object.freeze(obj);
          Object.keys(obj).forEach( (key, i) => {
            if ( typeof obj[key] === 'object' ) {
              constantize( obj[key] );
            }
          });
        };

    4.顶层对象的属性
      顶层对象的属性与全局变量挂钩(var命令和function命令在顶层声明)
      全局变量将逐步与顶层对象的属性脱钩(let命令、const命令、class命令在顶层声明)

    5.global 对象

  变量的解构赋值
    1.数组的解构赋值
      let [a, b, c] = [1, 2, 3];

    2.对象的解构赋值
      let { foo, bar } = { foo: "aaa", bar: "bbb" };

    3.字符串的解构赋值
      const [a, b, c, d, e] = 'hello';
        a // "h"
        b // "e"
        c // "l"
        d // "l"
        e // "o"

    4.数值和布尔值的解构赋值
    5.函数参数的解构赋值
    6.圆括号问题
    7.用途
      let x = 1;let y = 2;
      [x, y] = [y, x];

  字符串的扩展
    includes(), startsWith(), endsWith()
      includes()：返回布尔值，表示是否找到了参数字符串。
      startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
      endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
      let s = 'Hello world!';
        s.startsWith('Hello') // true
        s.endsWith('!') // true
        s.includes('o') // true

    repeat()
      repeat方法返回一个新字符串，表示将原字符串重复n次。
      'x'.repeat(3) // "xxx"
      'hello'.repeat(2) // "hellohello"
      'na'.repeat(0) // ""

    padStart()，padEnd()
      'x'.padStart(4, 'ab') // 'abax'
      'x'.padEnd(5, 'ab') // 'xabab'

      'xxx'.padStart(2, 'ab') // 'xxx'
      'xxx'.padEnd(2, 'ab') // 'xxx'

      'x'.padStart(4) // '   x'
      'x'.padEnd(4) // 'x   '

      '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
      '09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
  数值的扩展
    Number.isFinite()
      Number.isFinite(15); // true
      注意，如果参数类型不是数值，Number.isFinite一律返回false。

    Number.isNaN()
      Number.isNaN(NaN); // true
      如果参数类型不是NaN，Number.isNaN一律返回false。

    Number.parseInt(), Number.parseFloat()
      ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
      这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

    Number.isInteger()
      Number.isInteger(25) // true
      Number.isInteger()用来判断一个数值是否为整数。

      Number.isInteger(3.0000000000000002) // true
      Number.isInteger(5E-324) // false  5E-324最小值
      Number.isInteger(5E-325) // true
      总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。

    Number.EPSILON
      处理小数问题

    安全整数 和 Number.isSafeInteger()
      ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个常量，用来表示这个范围的上下限。
       Number.isSafeInteger() 用来判断这 整数 是否在这范围中

    Math.trunc()
      Math.trunc方法用于去除一个数的小数部分，返回整数部分

    Math.sign()
      Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
        参数为正数，返回+1；
        参数为负数，返回-1；
        参数为 0，返回0；
        参数为-0，返回-0;
        其他值，返回NaN。

    Math.cbrt()
      Math.cbrt方法用于计算一个数的立方根。 // 三次方

    Math.hypot()
      Math.hypot方法返回所有参数的平方和的平方根。
      就是所有参数的平方和 的 平方根

    Math.clz32(), Math.imul(), Math.fround()
      不懂

    对数方法(不懂)
      Math.expm1(), Math.log1p(), Math.log10(), Math.log2()

    双曲函数方法
      Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
      Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
      Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
      Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
      Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
      Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）
    
    指数运算符 (**)
      2 ** 2 // 4
      2 ** 3 // 8
      指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。
        let a = 1.5;
        a **= 2;
        // 等同于 a = a * a;

        let b = 4;
        b **= 3;
        // 等同于 b = b * b * b;
      注意，在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。
        Math.pow(99, 99)
        // 3.697296376497263e+197

        99 ** 99
        // 3.697296376497268e+197

  Map
    它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键
    const m = new Map();
    m.set(key, value); // 写入
    .get(key); // 读取值
    .has(key); // 判断是否包含
    .delete(key); // 删除这键值对
    .clear(); // 清空

    作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。
    const map = new Map([['name', '张三'], ['title', 'Author']]);

      事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。
      这就是说，Set和Map都可以用来生成新的 Map。

    Map 结构原生提供三个遍历器生成函数和一个遍历方法。
      keys()：返回键名的遍历器。
      values()：返回键值的遍历器。
      entries()：返回所有成员的遍历器。
      forEach()：遍历 Map 的所有成员。
        for (let key of map.keys()) {console.log(key);}

        for (let [key, value] of map) {console.log(key, value);} // 等同于使用map.entries() 
    
    Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。

  WeakMap
    WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
    它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。

  Set
    ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
    const s = new Set();
      s.add(value); // 写入
       .has(value); // 判断是否包含
       .delete(value); // 删除这键值对
       .clear(); // 清空

    Set 结构的实例有四个遍历方法，可以用于遍历成员。
      keys()：返回键名的遍历器
      values()：返回键值的遍历器
      entries()：返回键值对的遍历器
      forEach()：使用回调函数遍历每个成员
      for (let item of set.keys()) {console.log(item);}

  WeakSet
    WeakSet 的成员只能是对象，而不能是其他类型的值。
    WeakSet 里面的引用，都不计入垃圾回收机制。

  Proxy
    Proxy 支持的拦截操作一览，一共 13 种。http://es6.ruanyifeng.com/#docs/proxy
      apply()
        apply方法拦截函数的调用、call和apply操作。
        apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。
      has()
        has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。
      construct() 
        construct方法用于拦截new命令，下面是拦截对象的写法。
      ...

      new Proxy({}, {
        cur: 当前对象
        key: 对象里的属性
        p：实例化的Proxy对象
        目标对象、属性名 和 Proxy 实例本身
        get (cur,key,p) {console.log(cur,key,p);return cur[key]},

        val: 要赋予给属性的值
        目标对象、属性名、属性值和 Proxy 实例本身
        注意，严格模式下，set代理如果没有返回true，就会报错。
        set (cur,key,val,p) {console.log(cur,key,val,p);cur[key]=val;return true;}
        // 可以用来限制某个值得范围，限制可写属性
      });

      下面的例子则是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。
      const dom = new Proxy({}, {
        get(target, property) {
          return function(attrs = {}, ...children) {
            const el = document.createElement(property);
            for (let prop of Object.keys(attrs)) {
              el.setAttribute(prop, attrs[prop]);
            }
            for (let child of children) {
              if (typeof child === 'string') {
                child = document.createTextNode(child);
              }
              el.appendChild(child);
            }
            return el;
          }
        }
      });
      const el = dom.div({},
        'Hello, my name is ',
        dom.a({href: '//example.com'}, 'Mark'),
        '. I like:',
        dom.ul({},
          dom.li({}, 'The web'),
          dom.li({}, 'Food'),
          dom.li({}, '…actually that\'s it')
        )
      );
      document.body.appendChild(el);

    Proxy.revocable()
      Proxy.revocable方法返回一个可取消的 Proxy 实例。
      let {proxy, revoke} = Proxy.revocable({}, {});
      revoke() // 执行后取消proxy的实例

    this 问题
      目标对象内部的this关键字会指向 Proxy 代理

      此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。
      this绑定原始对象，就可以解决这个问题。
        const target = new Date('2015-01-01');
        const handler = {
          get(target, prop) {
            if (prop === 'getDate') {
              return target.getDate.bind(target);
            }
            return Reflect.get(target, prop);
          }
        };
        const proxy = new Proxy(target, handler);
        proxy.getDate() // 1
     
  Reflect
    http://es6.ruanyifeng.com/#docs/reflect
    Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。
    1.将Object对象的一些明显属于语言内部的方法
    2.修改某些Object方法的返回结果，让其变得更合理。
    3.让Object操作都变成函数行为
    4.Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。
      这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础
      也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。

    Reflect.has(obj, 'assign')  判断对象里是否有这键
      等于 'a' in obj

    Reflect.defineProperty(obj, 'asdff', {value: 12333333})  修改或新增键值
      等于 Object.defineProperty
      https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty

    Reflect.set 它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能,配合着Proxy
    Reflect.get

    每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。
    添加的工作，就是将每一个操作输出一行日志。
  
    Reflect对象一共有 13 个静态方法。
      Reflect.apply(target, thisArg, args)
      Reflect.construct(target, args)
      Reflect.get(target, name, receiver) // 第三个参数把指向从target变到receiver
      Reflect.set(target, name, value, receiver)
      Reflect.defineProperty(target, name, desc)
      Reflect.deleteProperty(target, name)
      Reflect.has(target, name)
      Reflect.ownKeys(target)
      Reflect.isExtensible(target)
      Reflect.preventExtensions(target)
      Reflect.getOwnPropertyDescriptor(target, name)
      Reflect.getPrototypeOf(target)
      Reflect.setPrototypeOf(target, prototype) 
      上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的

    实例：使用 Proxy 实现观察者模式
      const queuedObservers = new Set();
      const observe = fn => queuedObservers.add(fn);
      const observable = obj => new Proxy(obj, {set});
      function set(target, key, value, receiver) {
        const result = Reflect.set(target, key, value, receiver);
        queuedObservers.forEach(observer => observer());
        return result;
      }

      const person = observable({
        name: '张三',
        age: 20
      });
      function print() {
        console.log(`${person.name}, ${person.age}`)
      }
      observe(print);
      person.name = '李四';

  Promise
    Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。

    该函数的两个参数分别是 resolve 和 reject ,它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

    有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。
      从pending变为fulfilled和从pending变为rejected

    Promise 新建后立即执行, 然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行

    new Promise 当多层嵌套(new Promise)后，会返回最里面一层的数据，以最里面的 resolve, reject 为准.
      最里面一层先执行

    调用resolve或reject并不会终结 Promise 的参数函数的执行。所以，最好在它们前面加上return语句，这样就不会有意外。