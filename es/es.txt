ES6:

  ES6 声明变量的六种方法
    ES5 只有两种声明变量的方法：var命令和function命令。
    ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。
    所以，ES6 一共有 6 种声明变量的方法。

  let 和 const 命令
    http://es6.ruanyifeng.com/#docs/let#const-命令
    1.let 命令
      let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
      不存在变量提升
      暂时性死区
      不允许重复声明

    2.块级作用域
      {} 相当于 (function(){})()
      在块作用域里声明函数用 函数表达式 声明
        如： let f = function () {
              return a;
            };

    3.const 命令
      声明一个只读的常量。一旦声明，常量的值就不能改变。
      普通的值可以保证不变，但是对象和数组只能保证指向内存的指针不变
      如果想将对象完全冻结就用到 Object.freeze({})
      除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。
        var constantize = (obj) => {
          Object.freeze(obj);
          Object.keys(obj).forEach( (key, i) => {
            if ( typeof obj[key] === 'object' ) {
              constantize( obj[key] );
            }
          });
        };

    4.顶层对象的属性
      顶层对象的属性与全局变量挂钩(var命令和function命令在顶层声明)
      全局变量将逐步与顶层对象的属性脱钩(let命令、const命令、class命令在顶层声明)

    5.global 对象

  变量的解构赋值
    1.数组的解构赋值
      let [a, b, c] = [1, 2, 3];

    2.对象的解构赋值
      let { foo, bar } = { foo: "aaa", bar: "bbb" };

    3.字符串的解构赋值
      const [a, b, c, d, e] = 'hello';
        a // "h"
        b // "e"
        c // "l"
        d // "l"
        e // "o"

    4.数值和布尔值的解构赋值
    5.函数参数的解构赋值
    6.圆括号问题
    7.用途
      let x = 1;let y = 2;
      [x, y] = [y, x];

  字符串的扩展
    includes(), startsWith(), endsWith()
      includes()：返回布尔值，表示是否找到了参数字符串。
      startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
      endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
      let s = 'Hello world!';
        s.startsWith('Hello') // true
        s.endsWith('!') // true
        s.includes('o') // true

    repeat()
      repeat方法返回一个新字符串，表示将原字符串重复n次。
      'x'.repeat(3) // "xxx"
      'hello'.repeat(2) // "hellohello"
      'na'.repeat(0) // ""

    padStart()，padEnd()
      'x'.padStart(4, 'ab') // 'abax'
      'x'.padEnd(5, 'ab') // 'xabab'

      'xxx'.padStart(2, 'ab') // 'xxx'
      'xxx'.padEnd(2, 'ab') // 'xxx'

      'x'.padStart(4) // '   x'
      'x'.padEnd(4) // 'x   '

      '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
      '09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
  数值的扩展
    Number.isFinite()
      Number.isFinite(15); // true
      注意，如果参数类型不是数值，Number.isFinite一律返回false。

    Number.isNaN()
      Number.isNaN(NaN); // true
      如果参数类型不是NaN，Number.isNaN一律返回false。

    Number.parseInt(), Number.parseFloat()
      ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
      这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

    Number.isInteger()
      Number.isInteger(25) // true
      Number.isInteger()用来判断一个数值是否为整数。

      Number.isInteger(3.0000000000000002) // true
      Number.isInteger(5E-324) // false  5E-324最小值
      Number.isInteger(5E-325) // true
      总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。

    Number.EPSILON
      处理小数问题

    安全整数 和 Number.isSafeInteger()
      ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个常量，用来表示这个范围的上下限。
       Number.isSafeInteger() 用来判断这 整数 是否在这范围中

    Math.trunc()
      Math.trunc方法用于去除一个数的小数部分，返回整数部分

    Math.sign()
      Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
        参数为正数，返回+1；
        参数为负数，返回-1；
        参数为 0，返回0；
        参数为-0，返回-0;
        其他值，返回NaN。

    Math.cbrt()
      Math.cbrt方法用于计算一个数的立方根。 // 三次方

    Math.hypot()
      Math.hypot方法返回所有参数的平方和的平方根。
      就是所有参数的平方和 的 平方根

    Math.clz32(), Math.imul(), Math.fround()
      不懂

    对数方法(不懂)
      Math.expm1(), Math.log1p(), Math.log10(), Math.log2()

    双曲函数方法
      Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
      Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
      Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
      Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
      Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
      Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）
    
    指数运算符 (**)
      2 ** 2 // 4
      2 ** 3 // 8
      指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。
        let a = 1.5;
        a **= 2;
        // 等同于 a = a * a;

        let b = 4;
        b **= 3;
        // 等同于 b = b * b * b;
      注意，在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。
        Math.pow(99, 99)
        // 3.697296376497263e+197

        99 ** 99
        // 3.697296376497268e+197

  Map
    它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键
    const m = new Map();
    m.set(key, value); // 写入
    .get(key); // 读取值
    .has(key); // 判断是否包含
    .delete(key); // 删除这键值对
    .clear(); // 清空

    作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。
    const map = new Map([['name', '张三'], ['title', 'Author']]);

      事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。
      这就是说，Set和Map都可以用来生成新的 Map。

    Map 结构原生提供三个遍历器生成函数和一个遍历方法。
      keys()：返回键名的遍历器。
      values()：返回键值的遍历器。
      entries()：返回所有成员的遍历器。
      forEach()：遍历 Map 的所有成员。
        for (let key of map.keys()) {console.log(key);}

        for (let [key, value] of map) {console.log(key, value);} // 等同于使用map.entries() 
    
    Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。

  WeakMap
    WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
    它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。

  Set
    ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
    const s = new Set();
      s.add(value); // 写入
       .has(value); // 判断是否包含
       .delete(value); // 删除这键值对
       .clear(); // 清空

    Set 结构的实例有四个遍历方法，可以用于遍历成员。
      keys()：返回键名的遍历器
      values()：返回键值的遍历器
      entries()：返回键值对的遍历器
      forEach()：使用回调函数遍历每个成员
      for (let item of set.keys()) {console.log(item);}

  WeakSet
    WeakSet 的成员只能是对象，而不能是其他类型的值。
    WeakSet 里面的引用，都不计入垃圾回收机制。

  Proxy
    Proxy 支持的拦截操作一览，一共 13 种。http://es6.ruanyifeng.com/#docs/proxy
      apply()
        apply方法拦截函数的调用、call和apply操作。
        apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。
      has()
        has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。
      construct() 
        construct方法用于拦截new命令，下面是拦截对象的写法。
      ...

      new Proxy({}, {
        cur: 当前对象
        key: 对象里的属性
        p：实例化的Proxy对象
        目标对象、属性名 和 Proxy 实例本身
        get (cur,key,p) {console.log(cur,key,p);return cur[key]},

        val: 要赋予给属性的值
        目标对象、属性名、属性值和 Proxy 实例本身
        注意，严格模式下，set代理如果没有返回true，就会报错。
        set (cur,key,val,p) {console.log(cur,key,val,p);cur[key]=val;return true;}
        // 可以用来限制某个值得范围，限制可写属性
      });

      下面的例子则是利用get拦截，实现一个生成各种 DOM 节点的通用函数dom。
      const dom = new Proxy({}, {
        get(target, property) {
          return function(attrs = {}, ...children) {
            const el = document.createElement(property);
            for (let prop of Object.keys(attrs)) {
              el.setAttribute(prop, attrs[prop]);
            }
            for (let child of children) {
              if (typeof child === 'string') {
                child = document.createTextNode(child);
              }
              el.appendChild(child);
            }
            return el;
          }
        }
      });
      const el = dom.div({},
        'Hello, my name is ',
        dom.a({href: '//example.com'}, 'Mark'),
        '. I like:',
        dom.ul({},
          dom.li({}, 'The web'),
          dom.li({}, 'Food'),
          dom.li({}, '…actually that\'s it')
        )
      );
      document.body.appendChild(el);

    Proxy.revocable()
      Proxy.revocable方法返回一个可取消的 Proxy 实例。
      let {proxy, revoke} = Proxy.revocable({}, {});
      revoke() // 执行后取消proxy的实例

    this 问题
      目标对象内部的this关键字会指向 Proxy 代理

      此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。
      this绑定原始对象，就可以解决这个问题。
        const target = new Date('2015-01-01');
        const handler = {
          get(target, prop) {
            if (prop === 'getDate') {
              return target.getDate.bind(target);
            }
            return Reflect.get(target, prop);
          }
        };
        const proxy = new Proxy(target, handler);
        proxy.getDate() // 1
     
  Reflect
    http://es6.ruanyifeng.com/#docs/reflect
    Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。
    1.将Object对象的一些明显属于语言内部的方法
    2.修改某些Object方法的返回结果，让其变得更合理。
    3.让Object操作都变成函数行为
    4.Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。
      这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础
      也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。

    Reflect.has(obj, 'assign')  判断对象里是否有这键
      等于 'a' in obj

    Reflect.defineProperty(obj, 'asdff', {value: 12333333})  修改或新增键值
      等于 Object.defineProperty
      https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty

    Reflect.set 它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能,配合着Proxy
    Reflect.get

    每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。
    添加的工作，就是将每一个操作输出一行日志。
  
    Reflect对象一共有 13 个静态方法。
      Reflect.apply(target, thisArg, args)
      Reflect.construct(target, args)
      Reflect.get(target, name, receiver) // 第三个参数把指向从target变到receiver
      Reflect.set(target, name, value, receiver)
      Reflect.defineProperty(target, name, desc)
      Reflect.deleteProperty(target, name)
      Reflect.has(target, name)
      Reflect.ownKeys(target)
      Reflect.isExtensible(target)
      Reflect.preventExtensions(target)
      Reflect.getOwnPropertyDescriptor(target, name)
      Reflect.getPrototypeOf(target)
      Reflect.setPrototypeOf(target, prototype) 
      上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的

    实例：使用 Proxy 实现观察者模式
      const queuedObservers = new Set();
      const observe = fn => queuedObservers.add(fn);
      const observable = obj => new Proxy(obj, {set});
      function set(target, key, value, receiver) {
        const result = Reflect.set(target, key, value, receiver);
        queuedObservers.forEach(observer => observer());
        return result;
      }

      const person = observable({
        name: '张三',
        age: 20
      });
      function print() {
        console.log(`${person.name}, ${person.age}`)
      }
      observe(print);
      person.name = '李四';

  Promise
    Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。

    该函数的两个参数分别是 resolve 和 reject ,它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

    有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。
      从pending变为fulfilled和从pending变为rejected

    Promise 新建后立即执行, 然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行.可以采用链式写法

    new Promise 当多层嵌套(new Promise)后，会返回最里面一层的数据，以最里面的 resolve, reject 为准.
      最里面一层先执行
      它们之中任何一个抛出的错误，都会被最后一个catch捕获。

    调用resolve或reject并不会终结 Promise 的参数函数的执行。所以，最好在它们前面加上return语句，这样就不会有意外。

    Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。

    Promise.prototype.then()     then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数
    Promise.prototype.catch()    用于指定发生错误时的回调函数。
    Promise.prototype.finally()   finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。
      不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。
      当放在then和catch前面后会优先执行

    Promise.all()             Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
      const p = Promise.all([p1, p2, p3]);
      （Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）
      只有所有的 Promise 数据 状态都变成fulfilled，返回的状态才会变成fulfilled
      只要 Promise 数据 之中有一个被rejected，返回的状态就变成rejected
      注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。
        但只是当前的 Promise 实例，返回的数据是错误的，依然会执行 Promise.all().then()
        
    Promise.race()          Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
      const p = Promise.race([p1, p2, p3]);
      基本同上，但是会率先返回,执行 Promise.race() 的 then，其他的不会在执行 Promise.race() 的 then

    可以直接这样抛出去
      Promise.resolve(2)  将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。
        Promise.resolve('foo')
        // 等价于
        new Promise(resolve => resolve('foo'))
      Promise.reject(2)   方法也会返回一个新的 Promise 实例，该实例的状态为rejected。

    const promise = new Promise(function(resolve, reject) {
      // ... some code
      if (/* 异步操作成功 */){
        resolve(value);
      } else {
        reject(error);
      }
    });

  Generator 函数的语法
    Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。
    Generator 函数是一个普通函数，但是有两个特征。
      一是，function关键字与函数名之间有一个星号；
      二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。
      function* helloWorldGenerator() {
        yield 'hello';
        yield 'world';
        return 'ending';
      }
      var hw = helloWorldGenerator();
      必须调用遍历器对象的next方法，使得指针移向下一个状态。
      也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。
      换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。
      
    yield 表达式