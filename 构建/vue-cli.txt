

http://blog.csdn.net/xidongdong1/article/details/78613654		Vue中一些需要注意的点（采坑）

http://blog.csdn.net/sinat_29412671/article/details/53690658
https://juejin.im/post/583d1fe00ce463006baca2fa?utm_source=gold_browser_extension#heading-6

Vue 构建单页应用


	1.使用vue-cli创建项目
	2.使用vue-router实现单页路由
	3.用vuex管理我们的数据流
	4.使用vue-resource请求我们的node服务端
	5.使用.vue文件进行组件化的开发

	基于webpack开发,简单介绍webpack:

		1.我们将会使用webpack去为我们的模块打包，预处理，热加载。如果你对webpack不熟悉，它就是可以帮助我们把多个js文件打包为1个入口文件，并且可以达到按需加载。这就意味着，我们不用担心由于使用太多的组件，导致了过多的HTTP请求，这是非常有益于产品体验的。但我们并不只是为了这个而使用webpack，我们需要用webpack去编译.vue文件，如果没有使用一个loader去转换我们.vue文件里的style、js和html，那么浏览器就无法识别。

		2.模块热加载是webpack的一个非常碉堡的特性，将会为我们的单页应用带来极大的便利。通常来说，当我们修改了代码刷新页面，那应用里的所有状态就都没有了。这对于开发一个单页应用来说是非常痛苦的，因为需要重新在跑一遍流程。如果有模块热加载，当你修改了代码，你的代码会直接修改，页面并不会刷新，所以状态也会被保留。


	步骤：
		1.安装node、npm，在创建vue-cli(确保你有node和npm)。

			npm是什么东东？npm其实是Node.js的包管理工具（package manager）。

			为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。

			其实npm已经在Node.js安装的时候顺带装好了。

			版本号查询 node -v
					   npm -v

	    2.全局安装vue-cli  // "version": "2.9.2",
			
	    	默认路径:C:\Users\xxx\AppData\Roaming\npm
	    	$ npm install -g vue-cli
	    	这样方便经常使用的的依赖

    	3.创建项目(p:vue创建项目.png)
    		$ vue init webpack vue-tutorial   'vue-tutorial'为项目名称
    			Project name ...
    			Project description(描述) ...
    			Author(作者) ...
    			Vue build(vue公司创建) ...
    			Use ESlint to lint your code?(ESlint语法规范检查工具) ...
    			Set up unit tests(设置单元测试) ...
    			Setup e2e tests with Nightwatch(单元测试不需要) ...

		4.进入项目根目录的控制台
			$ npm run dev 在热加载中运行应用
			默认路径是 http://localhost:8080 端口被占用，会自动更换
			更改路径可以在根目录的 config->index.js 里找到 host 进行更改

		5.发布项目
			https://www.cnblogs.com/qiu-Ann/p/7477593.html
			http://blog.csdn.net/liangxhblog/article/details/78866066
			http://bbs.csdn.net/topics/391984869
			打包好 $ npm run build 必须放到服务器上

			路径出错的话改根目录下:
				build->webpack.base.conf.js
					output:{ publicPath:'./' } 改output里的publicPath参数

			图片路径错误的话改根目录下:
				build->utils.js
					找到以下这部分
					// Extract CSS when that option is specified
    				// (which is the case during production build)
					{publicPath:'../../'} 加上这个
    				例子：if (options.extract) {
						      return ExtractTextPlugin.extract({
						        use: loaders,
						        fallback: 'vue-style-loader',
						~~~~~~~ publicPath:'../../'
						      })
						    } else {
						      return ['vue-style-loader'].concat(loaders)
						    }	


	vue的使用
		vue-resource 进行请求数据
		vue-router	 路由管理
		vuex 管理我们的数据流

		在根目录的 package.json 可以查看和配置信息
		当需要依赖时，在更目录下通过 $ npm install vue-resource(名) 来进行安装
		安装多个npm install vue-resource vue-router vuex bootstrap --save

		入口在根目录的 src->main.js
			src->assets 			放些自己的文件
			src->components			放组件文件
			src->router->index.js   不同路径对应不同的组件(路由配置)

			在里层的文件可以通过 @/ 直接回到src目录下，比如:
				在 src->router->index.js 下引入 src->components->HelloWorld.vue	的组件
			   		直接写 import HelloWorld from '@/components/HelloWorld'

   		Vue.use()
   			像vue的插件要通过Vue.use来绑定上去
   			参数必须是:
   			函数
   			  或
   			对象(传对象会执行install函数，这时候把js绑定到vue里Vue.prototype.myjs = myjs)
   			

		vue-router
			通过Vue.use绑定到vue上
			this.$route 可以获取当前的路径信息
			this.$router.push()			可以直接写字符串,也可以传对象(必须按this.$route的格式来)
						.back() 		后退,传-1,如	this.$router.back(-1);
						.replace()		改变当前路径,如 this.$router.replace(this.$route.path + '?go=true')

		vue-resource	vue数据请求
			通过Vue.use绑定到vue上
			路径,参数
			this.$http.post(self.ajaxUrl,o).then(function(res){
				console.warn(res);
			});

		vue-router		vue路由
			new Router({
				//所有的路径写在routes的数组里
				routes:[{
			      	path: '/',				//定义路径
			      	name: 'Index',			//这个组件的名
			      	component: Index,		//组件的内容
			      	children:[{				//该组件下的子组件
			        	path:'calendar',
			      	}]
			    },{
			      	path: '/lists',
			      	name: 'Lists',
			      	component: Lists,
			      	children:[{
		      	  		path:'calendar',
	      			},{
			        	path: 'detail/:id',		//携带参数
			        	name: 'Detail',
			        	component: Detail,
			        	children:[{
			        	  	path:'calendar',
			        	},{
			        	  	path:'all_img',
			        	},{
			        	  	path:'more',
			        	  	name: 'DetailMore',
			        	  	component: DetailMore
			        	},{
			        	  	path: 'comment/:tk',
			        	  	component: Comment,
			        	  	children:[{
			        	    	path:'discuss'
			        	  	}]
			        	},{
			        	  	path:'s_order',
			        	  	component: SubmitOrder,
			        	  	children:[{
			        	    	path:'o_detail'
	        	  			}]
	       				}]
			      	}]
			    }]
			})

		组件间通信
			1.子调父
				1)this.$parent.(变量名或函数)

				2)在父里<router-view
							:bianliang1="bianliang1"
							:bianliang2="bianliang2"
						/>
				  在子里 props:['bianliang1','bianliang2'] 变成自己的

				3)在父里<router-view
							v-on:msg1="fun1"
							v-on:msg2="fun2"
						/>
				 在子里 this.$emit('msg1','') 第一个是函数名，必须在父里v-on:msg1才能调用
				 							  第二个是这函数需要的传参，没有可不填






















































