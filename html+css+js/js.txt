


js
	技巧
		in 
			判断对象是否包含key 如：'d' in obj
			判断数组是否包含index 如：0 in arr
			返回true，false

		window.parent.document  在iframe里可以获取到父窗口
		window.parent.document.getElementsByTagName('iframe')[0]   在iframe里可以获取到当前iframe

		isNaN() 判断能否转成数值，true 不能， false 可以

		Number()、parseInt()、parseFloat() 把非数值转换为数值

		document.documentElement.scrollTop 获取滚动距离

		当内置的对象自带方法不满足时，可以通过 prototype 原型来给对象添加方法

		Array.isArray(val) 判断 val值 是否数组
	
	语法
		var 关键词来声明变量：var carname;
		全局变量：不要加var

		数据类型：字符串、数字、布尔、数组、对象、Null、Undefined

		函数创建：
			function f(){}
			var f2 = function(){};

		js中的所有事物都是对象,属性和方法是对象的成员，属性是值，方法是执行的动作。
		对象创建：
			var obj = {}
			var obj1 = new Object();
			var obj2 = new f2();

		算术运算符
			+		加
			-		减
			*		乘
			/		除
			%		求余数 (保留整数)
			++		累加
			--		递减

		赋值运算符
			=
			+=
			-=
			*=
			/=
			%=

		比较运算符
			==		等于
			===		全等（值和类型）
			!=		不等于
			>		大于
			<		小于
			>=		大于或等于
			<=		小于或等于

		条件语句	
			if(){} 语句 - 只有当指定条件为 true 时，使用该语句来执行代码
			if(){}else{} 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码
			if(){}else if(){}else{} 语句 - 使用该语句来选择多个代码块之一来执行
			switch 语句 - 使用该语句来选择多个代码块之一来执行
				switch(n){
					case 1:
					  执行代码块 1
					  break;
					case 2:
					  执行代码块 2
					  break;
					default:
					  不匹配执行的代码
				}

		循环
			break 语句用于跳出循环。
			continue 用于跳过循环中的一个迭代。

			for - 循环代码块一定的次数
				for (var i=0;i<cars.length;i++){
					document.write(cars[i] + "<br>");
				}

			for/in - 循环遍历对象的属性
				var person={fname:"John",lname:"Doe",age:25};
				for (x in person){
				  	txt=txt + person[x];
				}

			while - 当指定的条件为 true 时循环指定的代码块,先判断再执行
				while (i<5)
				  	x=x + "The number is " + i + "<br>";
				  	i++;
				}

			do/while - 同样当指定的条件为 true 时循环指定的代码块,先执行再判断
				do{
				  	x=x + "The number is " + i + "<br>";
				  	i++;
				}while (i<5);

		异常错误
			try 语句测试代码块的错误。
			catch 语句处理错误。
				try{
				  	//在这里运行代码
				}catch(err){
				  	//在这里处理错误
				}

			throw 语句创建自定义错误。
				http://www.w3school.com.cn/js/js_errors.asp
				try{
					if(x=="")throw "empty";//这里条件满足，抛出错误
				}catch(err){
					console.log(err);//打印的是empty
				}

	DOM (http://www.w3school.com.cn/jsref/dom_obj_all.asp)
		改变 HTML 输出流
			document.write() 可用于直接向 HTML 输出流写内容。

		改变 HTML 元素的样式
			document.getElementById("p2").style.color="blue";

		对象
			document(文档)
				创建新的 HTML 元素
					var para=document.createElement("p");//创建p节点
					var node=document.createTextNode("这是新段落。");//创建文本节点
					para.appendChild(node);//向p里添加文本节点
					parent.removeChild(child);//从父元素中删除子元素

				获取节点
					getElementById() 				通过id获取
					getElementsByName()				通过name值获取，返回的是数组
					getElementsByTagName()			通过标签名获取，返回的是数组
					getAttributeNode()				返回指定的属性节点。
					querySelector()					返回匹配指定 CSS 选择器元素的第一个子元素
					querySelectorAll()				返回匹配指定 CSS 选择器元素的所有子元素节点列表

			元素对象 就是获取到节点后的操作 (节点操作)

				scrollLeft				返回元素左边缘与视图之间的距离。
				scrollTop				返回元素上边缘与视图之间的距离。
				offsetLeft				返回元素的水平偏移位置。
				offsetTop				返回元素的垂直偏移位置。

				clientHeight			返回元素的可见高度。
				clientWidth				返回元素的可见宽度。
				scrollHeight			返回元素的整体高度。
				scrollWidth				返回元素的整体宽度。
				offsetHeight			返回元素的高度。
				offsetWidth				返回元素的宽度。
				offsetParent			返回元素的偏移容器。
				
				hasAttribute			如果元素拥有指定属性，则返回true，否则返回 false。
				hasAttributes			如果元素拥有属性，则返回 true，否则返回 false。
				hasChildNodes			如果元素拥有子节点，则返回 true，否则 false。
				getAttribute			返回元素节点的指定属性值。
				getAttributeNode 		返回指定属性节点
				setAttribute			把指定属性设置或更改为指定值。
				setAttributeNode		设置或更改指定属性节点。
				removeAttribute			从元素中移除指定属性。
				removeAttributeNode		移除指定的属性节点，并返回被移除的节点。
				
				appendChild				向元素添加新的子节点，作为最后一个子节点。
				nextSibling				返回位于相同节点树层级的下一个节点。
				previousSibling			返回位于相同节点树层级的前一个元素。
				insertBefore			在指定的已有的子节点之前插入新节点。
				replaceChild			替换元素中的子节点。

				childNodes				返回元素子节点的 NodeList。是个数组包括文本节点
				children				返回元素子节点,没有其他多余节点
				firstChild				返回元素的首个子。
				lastChild				返回元素的最后一个子元素。
				parentNode				返回元素的父节点。
				removeChild				从元素中移除子节点。

				nodeName				返回元素的标记名（大写）
				nodeType				返回元素的节点类型。(1.元素,3.文本)
				nodeValue				设置或返回元素值。

				className				设置或返回元素的 class 属性。
				classList				返回元素的类名，作为 DOMTokenList 对象。
					add(c1,c2)				在元素中添加一个或多个类名。
					contains()				返回布尔值，判断指定的类名是否存在。
					remove(c1,c2)			移除元素中一个或多个类名。
					toggle(c)				在元素中切换类名。
				id 						设置或返回元素的 id。
				innerHTML				设置或返回元素的内容。
				style					设置或返回元素的 style 属性。
				tabIndex				设置或返回元素的 tab 键控制次序。
				tagName 				返回元素的标签名。
				textContent				设置或返回节点及其后代的文本内容。
				title					设置或返回元素的 title 属性。
				tabIndex				设置或返回元素的标签顺序。
				tagName 				作为一个字符串返回某个元素的标记名（大写）

				cloneNode				克隆元素。

			事件对象
				鼠标事件
					onclick 			当用户点击某个对象时调用的事件句柄。
					ondblclick 			当用户双击某个对象时调用的事件句柄。
					onmousedown			鼠标按钮被按下。
					onmousemove			鼠标被移动。
					onmouseout			鼠标从某元素移开。
					onmouseover			鼠标移到某元素之上。
					onmouseup			鼠标按键被松开。
					onmouseenter		当鼠标指针移动到元素上时触发。
					onmouseleave		当鼠标指针移出元素时触发
					onhover

					属性
						screenX				返回当某个事件被触发时，鼠标指针的水平坐标。
						screenY				返回当某个事件被触发时，鼠标指针的垂直坐标。
						clientX				返回当事件被触发时，鼠标指针的水平坐标。
						clientY				返回当事件被触发时，鼠标指针的垂直坐标。
						key 				在按下按键时返回按键的标识符。
						keyCode				返回键盘事件触发的键的值的字符代码
						which				返回键盘事件触发的键的值的字符代码

				键盘事件
					onkeydown			某个键盘按键被按下
					onkeypress			某个键盘按键被按下并松开。
					onkeyup				某个键盘按键被松开。

				框架/对象（Frame/Object）事件 (页面事件，生命周期)
					onabort				图像的加载被中断。
					onerror				在加载文档或图像时发生错误。
					onload 				一张页面或一幅图像完成加载。
					onpageshow			该事件在用户访问页面时触发
					onpagehide			该事件在用户离开当前网页跳转到另外一个页面时触发
					onunload			用户退出页面。
					onbeforeunload		该事件在即将离开页面（刷新或关闭）时触发
					onhashchange		该事件在当前 URL 的锚部分发生修改时触发。
					onresize			窗口或框架被重新调整大小。
					onscroll			当文档被滚动时发生的事件。  scrollTo(0,0)返回顶部

				表单事件
					onfocus				元素获得焦点。
					onblur				元素失去焦点。
					onchange			域的内容被改变。
					onsubmit			确认按钮被点击。
					oninput				元素获取用户输入时触发
					onpropertychange	同上，兼容ie
					onfocusin			元素即将获取焦点时触发
					onfocusout			元素即将失去焦点时触发 
					onsearch			用户向搜索域输入文本时触发 ( <input="search">)
					onreset				表单重置时触发
					onselect			用户选取文本时触发 ( <input> 和 <textarea>)

				剪贴板事件
					oncopy				该事件在用户拷贝元素内容时触发
					oncut 				该事件在用户剪切元素内容时触发
					onpaste				该事件在用户粘贴元素内容时触发
				
				打印事件
					onafterprint		该事件在页面已经开始打印，或者打印窗口已经关闭时触发
					onbeforeprint		该事件在页面即将开始打印时触发

				拖动事件
					ondrag 				该事件在元素正在拖动时触发
					ondragend			该事件在用户完成元素的拖动时触发
					ondragenter			该事件在拖动的元素进入放置目标时触发
					ondragleave			该事件在拖动元素离开放置目标时触发
					ondragover			该事件在拖动元素在放置目标上时触发
					ondragstart			该事件在用户开始拖动元素时触发
					ondrop				该事件在拖动元素放置在目标区域时触发

				多媒体（Media）事件
					http://www.runoob.com/jsref/dom-obj-event.html (搜：多媒体（Media）事件)

				动画事件
					animationend 		该事件在 CSS 动画结束播放时触发
					animationiteration 	该事件在 CSS 动画重复播放时触发
					animationstart 		该事件在 CSS 动画开始播放时触发

				过渡事件
					transitionend		该事件在 CSS 完成过渡后触发。

				其他事件
					onwheel				该事件在鼠标滚轮在元素上下滚动时触发
					http://www.runoob.com/jsref/dom-obj-event.html (搜：其他事件)

				方法
					addEventListener() 		允许在目标事件中注册监听事件(IE8 = attachEvent())
					removeEventListener()	运行一次注册在事件目标上的监听事件(IE8 = detachEvent())

					阻止事件
						preventDefault()	通知浏览器不要执行与事件关联的默认动作。
						stopPropagation()	不再派发事件。
			
	JavaScript 对象
		Array 对象
			prototype 				允许你向数组对象添加属性或方法。例：Array.prototype.aa = function(){}

			concat()				连接两个或更多的数组，并返回结果
			every()					检测数值元素的每个元素是否都符合条件。例：arr.every(function(a){return a>=1}) 返回true或false
			some()					同上
			filter()				检测数值元素，并返回符合条件所有元素的数组。例：arr.filter(function(a){return a>=1}) 返回新数组
			find()					返回指定的第一个值。例：arr.find(function(a){return a==2}) 当有等于2时，返回所有2中的第一个，否则undefined
			findIndex() 			返回指定值的第一个索引。例：arr.findIndex(function(a){return a==2}) 当有等于2时，返回所有2中的第一个索引，否则-1
			forEach()				数组每个元素都执行一次回调函数。方法用于调用数组的每个元素，并将元素传递给回调函数。例：arr.forEach(function(item,index){console.log(item)})
			indexOf()				搜索数组中的元素，并返回它所在的位置。返回指定值首次出现的索引。例：arr.indexOf("Apple");有则返回索引，否则-1
			lastIndexOf()			基本同上，这是从后面开始。
			join()					把数组的所有元素放入一个字符串，默认以逗号隔开,传参以参数为准。例：arr.join();
			toString()				同上
			valueOf()				同上
			map()					通过指定函数处理数组的每个元素，并返回处理后的数组。
			pop()					删除数组的最后一个元素并返回删除的元素。
			push()					向数组的末尾添加一个或更多元素，并返回新的长度。
			reduce()				将数组元素计算为一个值（从左到右）。例：arr.reduce(function(total, num){return total+num}) 
			reduceRight()			将数组元素计算为一个值（从右到左）。
			reverse()				反转数组的元素顺序。
			shift()					删除并返回数组的第一个元素。
			sort()					对数组的元素进行排序。
				对 进行对象数组排序，可以根据对象里的值进行排序
				var arr = [{a:3},{a:6}];
				arr.sort(function(a,b){
					return a.a > b.a
				})

			splice()				从数组中添加或删除元素,并返回添加或删除的数组给你
				array.splice(index,howmany,item1,.....,itemX)
				index插入的位置，必需
				howmany是否删除当前位置的值，不0，是1，必需
				item1插入的值，可多个，可选
			unshift()				向数组的开头添加一个或更多元素，并返回新的长度。

			以下为 es6

			from 				方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。
				Array.from(arrayLike, x => x * x)
				// 等同于
				Array.from(arrayLike).map(x => x * x)
				Array.from([1, 2, 3], (x) => x * x)

				Array.from({ length: 2 }, () => 'jack')
				// ['jack', 'jack'] 关键在length的长度
			
			of
				Array.of方法用于将一组值，转换为数组。
				Array.of() // []
				Array.of(undefined) // [undefined]
				Array.of(1) // [1]
				Array.of(1, 2) // [1, 2]

			数组实例的 copyWithin()
				数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
				Array.prototype.copyWithin(target, start = 0, end = this.length)
					target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
					start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
					end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

				[1, 2, 3, 4, 5].copyWithin(0, 3)
				// [4, 5, 3, 4, 5]

				// -2相当于3号位，-1相当于4号位,注意：好像要反过来
				[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
				// [4, 2, 3, 4, 5]
			
			数组实例的 fill()
				fill方法使用给定值，填充一个数组, 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。
					['a', 'b', 'c'].fill(7)
					// [7, 7, 7]
					new Array(3).fill(7)
					// [7, 7, 7]

					fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。
					['a', 'b', 'c'].fill(7, 1, 2)
					// ['a', 7, 'c']

					注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。
					let arr = new Array(3).fill([]);
					arr[0].push(5);
					arr
					// [[5], [5], [5]]

			数组实例的 entries()，keys() 和 values() 
				ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。
				它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。
				for (let index of ['a', 'b'].keys()) {
					console.log(index);
				}
				// 0
				// 1

				for (let elem of ['a', 'b'].values()) {
					console.log(elem);
				}
				// 'a'
				// 'b'

				for (let [index, elem] of ['a', 'b'].entries()) {
					console.log(index, elem);
				}
				// 0 "a"
				// 1 "b"

				如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。
				let letter = ['a', 'b', 'c'];
				let entries = letter.entries();
				console.log(entries.next().value); // [0, 'a']
				console.log(entries.next().value); // [1, 'b']
				console.log(entries.next().value); // [2, 'c']

			数组实例的 includes()
				Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。
				[1, 2, 3].includes(2)     // true
				[1, 2, 3].includes(4)     // false
				[1, 2, NaN].includes(NaN) // true

		

		Date 对象
			静态方法
				Date.parse()					接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数
				Date.UTC()						参数分别是 y,m(一月是0，二月是1，以此类推),d,h,m,s, 返回相应日期的毫秒数
																new Date(Date.UTC(2008, 11, 31)).toLocaleDateString()
				Date.now()						取得当前时间的时间戳

			对象上的实例方法
				getFullYear()			从 Date 对象以四位数字返回年份。
				getMonth()				从 Date 对象返回月份 (0 ~ 11)。
				getDate()				从 Date 对象返回一个月中的某一天 (1 ~ 31)。
				getHours()				返回 Date 对象的小时 (0 ~ 23)。
				getMinutes()			返回 Date 对象的分钟 (0 ~ 59)。
				getMilliseconds()		返回 Date 对象的毫秒(0 ~ 999)。

				getDay()				从 Date 对象返回一周中的某一天 (0 ~ 6)。
				getTime()				返回 1970 年 1 月 1 日至今的毫秒数。时间戳
				toISOString()			使用 ISO 标准返回字符串的日期格式。new Date().toISOString();
				toLocaleDateString() 	根据本地时间格式，把 Date 对象的日期部分转换为字符串。new Date().toLocaleDateString();
				toLocaleTimeString()	根据本地时间格式，把 Date 对象的时间部分转换为字符串。new Date().toLocaleTimeString();
				toLocaleString()		据本地时间格式，把 Date 对象转换为字符串。

				setFullYear()			
				setMonth()				
				setDate()				
				setHours()				
				setMinutes()			
				setMilliseconds()
				setTime()

		Math 对象
			http://www.runoob.com/jsref/jsref-obj-math.html
			都是静态属性和方法
			Math.E					自然对数的底数，即常量e的值
			Math.LN10				10的自然对数
			Math.LN2				2的自然对数
			Math.LOG2E				以2为底e的对数
			Math.LOG10E				以10为底e的对数
			Math.PI					π的值
			Math.SQRT1_2			1/2的平方根（即2的平方根的倒数）
			Math.SQRT2				2的平方根

			如果要从数组中找的话，可以用 apply()
				Math.max.apply(Math, [1,2,3,4,56,7])
				Math.max()				返回参数中最大的值
				Math.min()				返回参数中最小的值

			Math.abs(num)			返回num 的绝对值
			Math.asin(x)			返回x 的反正弦值
			Math.exp(num)			返回Math.E 的num 次幂
			Math.atan(x)			返回x 的反正切值
			Math.log(num)			返回num 的自然对数
			Math.atan2(y,x)			返回y/x 的反正切值
			Math.pow(num,power)		返回num 的power 次幂
			Math.cos(x)				返回x 的余弦值
			Math.sqrt(num)			返回num 的平方根
			Math.sin(x)				返回x 的正弦值
			Math.acos(x)			返回x 的反余弦值
			Math.tan(x)				返回x 的正切值
			
			Math.ceil(x)			对数进行上舍入。
			Math.floor(x)			对 x 进行下舍入。
			Math.round(x)			把数四舍五入为最接近的整数。
			Math.random()			返回 0 ~ 1 之间的随机数。
				Math.floor(Math.random() * 8 + 2) // 获取 2-8 之间的数，通过修改2和8，来改范围

		Number 对象
			http://www.runoob.com/jsref/jsref-obj-number.html
			toFixed(x)				指定小数为x位。
			toExponential(x)		指定小数为x位,带e表示
			toPrecision()

		String 对象
			http://www.runoob.com/jsref/jsref-obj-string.html
			String.fromCharCode()	静态方法，把 ascii码 转换为字符串

			charAt()				返回在指定位置的字符。
			charCodeAt() 			返回在指定的位置的字符的 Unicode 编码。
			concat()				连接两个或更多字符串，并返回新的字符串。

			第一个参数是查找的字符串，第二个参数都是指定开始的位置
				indexOf()				头开始，返回指定字符串第一次出现的索引，没有返回-1
				lastIndexOf()			基本同上，尾开始

			以下三个都是截取字符串，并返回
				传入的负值与字符串的长度相加，得到的位置index
				slice()					提取字符串的片断，并在新的字符串中返回被提取的部分。例：str.slice(1,5);
				substring(s,e)			基本同上。所有负值转化为 0
				substr(s,e)				基本同上。e指定的是个数(当为负时转化为 0)	版本 < ie9 传负值有问题
					var stringValue = "hello world";
					alert(stringValue.substr(3, 7)); 	//"lo worl"


			

			toLowerCase()			把字符串转换为小写。
			toLocaleLowerCase()		基本同上，针对地区的(使用针对地区的方法更稳妥一些)。
			toUpperCase()			把字符串转换为大写。
			toLocaleUpperCase()		基本同上，针对地区的(使用针对地区的方法更稳妥一些)。

			trim()					去除字符串两边的空白,并返回新的值
			trimLeft()				基本同上，去掉左边的
			trimRight()				基本同上，去掉右边的

			localeCompare()			比较字符串，判断在当前字符串的前后或相等
				var stringValue = "yellow";
				alert(stringValue.localeCompare("brick")); //前 1
				alert(stringValue.localeCompare("yellow")); //相等 0
				alert(stringValue.localeCompare("zoo")); //后 -1

			一下是支持正则表达式的 String 对象的方法
				replace()				在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串。例：str.replace(/^\s+|\s+$/g, '')
				match()					查找找到一个或多个正则表达式的匹配。例：str.match(/ain/g);
				search()				查找与正则表达式相匹配的值。
				split()					把字符串分割为数组并返回。第一个参数 分隔符，第二个参数 可以指定返回数据的 length  < ie8 有问题

		RegExp 对象 正则
			静态属性
				RegExp.input			最近一次要匹配的字符串
				RegExp.leftContext		最近一次的匹配项
				RegExp.rightContext		Input字符串中lastMatch之后的文本
				RegExp.lastMatch		最近一次的匹配项
				RegExp.lastParen		最近一次匹配的捕获组
				RegExp.multiline		布尔值，表示是否所有表达式都使用多行模式
				RegExp.$1				RegExp.$1、RegExp.$2...RegExp.$9，分别用于存储第一、第二...第九个匹配的捕获组

			实例方法
				toString()			返回正则表达式字符串
				toLocaleString()	返回正则表达式字符串
				valueOf()	返回正则表达式本身
				test() 		检索字符串中指定的值,返回 true 或 false。(验证)，例子: /^\s+|\s+$/g.test(str)
				exec()		检索字符串中指定的值。返回找到的值。例子: str = "Visit W3School"; /W3School/g.exec(str)

			/pattern(表达式)/flags(标志)
				3 个标志 (可组合使用)
					g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
					i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
					m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

					var pattern1 = /\[bc\]at/i;
						// 做判断
						alert(pattern1.global); //false
						alert(pattern1.ignoreCase); //true
						alert(pattern1.multiline); //false
						alert(pattern1.lastIndex); //0
						alert(pattern1.source); //"\[bc\]at"

		Function 对象
			函数声明
				率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；(相当于var的提升作用域)

			函数表达式
				至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行

			在函数内部，有两个特殊的对象：arguments 和this。
				arguments			包含所有参数的数组
				arguments.callee	指向自身的函数

			caller	这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null
				function outer(){inner()};function inner(){alert(inner.caller)};outer();

			例子:function f(){}

			每个JavaScript函数都会有很多附属的方法

			关键字 arguments
				代表一个参数对象，它只有一个代表长度(length)的属性类似于数组。

			toString()

			call()	
				方法会用它的第一个参数 作为 当前调用call()函数的this指针  例子:var obj={} f.call(obj)

			apply()
				apply()和call()类似的，只是apply()要求第二个参数必须是一个数组。
				这个数组会作为参数传递给目标函数，通过arguments数组来获取  例子:var obj={} f.apply(obj,['q','b','c'])
		
		Global 对象
			一个虚拟的对象，其实就是 window (自己的理解)
			var global = function(){return this;}(); // 手动创建 global 对象

			isNaN()
			isFinite()
			parseInt()
			parseFloat()

			编码
				encodeURI()					对链接的中文、空格进行转义 转成: %A4%AB
				encodeURIComponent()		对链接的符号和中文、空格进行转义 转成: %A4%AB

			解码
				decodeURI()					对应 encodeURI()，把编码转回原样
				decodeURIComponent()		对应 encodeURIComponent()，把编码转回原样

			eval()			解析字符串的JavaScript (要小心代码注入)
		
		Object 对象
			对象的高级操作
				属性类型
					1.数据属性，4个属性描述符
						configurable 		判断 能否使用 delete 删除，默认 ture，(设置为 false，严格模式下进行删除会报错)(设置为 false 后，其它的描述符不能在进行修改)
						enumerable	 		判断 是否循环改属性，默认 true
						writable			判断 能否修改改属性，默认 true，(设置为 false，严格模式下进行修改会报错)
						value				属性值，读取写入都是对改描述进行操作，默认 undefined

						使用 Object.defineProperty(a, b, c) 可以进行修改，a 对象、b Key值、c 要修改的描述符对象 (ie8 不要使用)
							var person = { name: 'Nicholas' };
							Object.defineProperty(person, 'name', { writable: false });
					
					2.访问器属性
						一对 getter 和 setter 函数 (不必要的，要做拦截操作可以定义来处理数据，严格模式下必须一对一起定义)
						对取值时调用 getter
						修改值时调用 setter
						4个描述符
							configurable		同上
							enumerable			同上
							get					在读取属性时调用的函数，默认值为undefined
							set					在写入属性时调用的函数，默认值为undefined

							同样必须用 Object.defineProperty() 来定义
								Object.defineProperty(person, 'name', {
									get () {...},
									set (nVal) {...}
								});
						
						ie9 才实现，旧的使用 __defineGetter__() 和 __defineSetter__()
							person.__defineGetter__('name', function () {})
							person.__defineSetter__('name', function (nVal) {})

				定义多个属性
					为对象定义多个属性的可能性很大，又定义了一个 Object.defineProperties(a, b) 方法，利用这个方法可以通过描述符一次定义多个属性。
					var person = {};
					Object.defineProperties(person, {
						name: { value: 'abc' },
						name2: { value: 'abc' },
						name3: {
							get () {},
							set (nVal) {}
						}
					})

				读取属性的特性
					Object.getOwnPropertyDescriptor(a, b) 读取对象里属性的描述，a 对象， b 对象里的Key (ie9 以上可使用)
						var person = {name: 'asdf'}
						Object.getOwnPropertyDescriptor(person, 'name')
			
			模式 (设计模式)
				工厂模式 (我的理解：就是封装公共的部分)
					function createPerson(name, age, job){
						var o = new Object();
						o.name = name;o.age = age;o.job = job;
						o.sayName = function(){
							alert(this.name);
						};
						return o;
					}

				构造函数模式
					相当于 java 的类
					function Person(name, age, job){
						this.name = name;this.age = age;this.job = job;
						this.sayName = function(){
							alert(this.name);
						};
					}
					var p = new Person("Greg", 27, "Doctor");

					p 有一个 constructor（构造函数）属性，该属性指向 Person
					对象的 constructor 属性最初是用来标识对象类型的，但是 instanceof 操作符要更可靠一些

					所有创建的对象既是 Object 的实例
					也是实例者(Person)的对象，是因为所有对象均继承自 Object

				原型模式
					每个函数都有一个 prototype（原型）属性，是一个指针，指向一个对象。
					用途是共享所有实例的属性和方法，这就解决了上面的设计模式存在的一个问题(通过 this 创建的引用类型，每次实例会产生新的内存空间)。
						function Person () {}
						Person.prototype.name = "Nicholas";
						Person.prototype.age = 29;
						Person.prototype.job = "Software Engineer";
						Person.prototype.sayName = function(){ alert(this.name) };
						var p = new Person();

						更简单的原型语法
						Person.prototype = {
							name : "Nicholas",
							age : 29,
							job: "Software Engineer",
							sayName : function () {
								alert(this.name);
							},
							/* 这种字面量写法会导致 Person.prototype.constructor 指向 Object，这是解决方法
							 * 缺点：导致它的 enumerable 描述符 被设置为true，可以使用 Object.defineProperty() 修改为false
							*/
							constructor : Person 
						};

					所有的实例对象都有一个 __proto__ 属性，指向实例函数的 prototype (也是构造函数的原型)
					当读取对象的某个属性时，先从当前 对象 找，找不到再从 对象的原型 里面找。而这正是 多个对象实例 共享原型 所保存的属性和方法的基本原理。
					原型的动态性(这里需要注意)
						Person.prototype 是个指针
						p.__proto__ 	 也是个指针
						在实例化对象后可以对 prototype 进行修改，但不能使用 字面量方法赋值对象

					isPrototypeOf()
						用来确定对象之间是否存在关系
						alert(Person.prototype.isPrototypeOf(p)); //true
					
					Object.getPrototypeOf() (ie9以上可用)
						这个方法返回 __proto__ 的值
						alert(Object.getPrototypeOf(p) === Person.prototype);

					hasOwnProperty()
						检测一个属性是存在于实例中，还是存在于原型中。在实例中返回 true
						alert(p.hasOwnProperty("name")); //false

					in 操作符
						'name' in p // 不管属性名在实例或者原型中，只要有就返回 true
						同时使用 hasOwnProperty() 方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。(因为 hasOwnProperty 在原型中找不到也是返回 false)
						function hasPrototypeProperty (object, name) { return !object.hasOwnProperty(name) && (name in object) }

					Object.keys()
						返回一个包含所有可枚举属性的字符串数组
						Object.keys(p)

					Object.getOwnPropertyNames()
						返回一个所有属性名的数组，无论它是否可枚举
						Object.getOwnPropertyNames(Person.prototype)

					原生对象的原型 (不推荐修改)
						原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。
						原生引用类型(Object、Array、String，等等).prototype = function () {...}

				组合使用 构造函数模式 和 原型模式 (用最广泛、认同度最高的一种创建自定义类型的方法)
					构造函数实现 私有数据
					原型模式实现 共享数据
					function Person(name, age, job){
						this.name = name;this.age = age;
						this.job = job;this.friends = ["Shelby", "Court"];
					}
					Person.prototype = {
						constructor : Person,
						sayName : function () { alert(this.name) }
					}

				动态原型模式
					function Person(name, age, job){
						//属性
						this.name = name;this.age = age;this.job = job;
						//方法
						if (typeof this.sayName != "function"){
							Person.prototype.sayName = function(){ alert(this.name) };
						}
					}

				寄生构造函数模式
					function SpecialArray(){
						//创建数组
						var values = new Array();
						//添加值
						values.push.apply(values, arguments);
						//添加方法
						values.toPipedString = function(){ return this.join("|") };
						//返回数组
						return values;
					}
					var colors = new SpecialArray("red", "blue", "green");
					alert(colors.toPipedString()); //"red|blue|green"
				
				稳妥构造函数模式
					function Person(name, age, job){
						//创建要返回的对象
						var o = new Object();
						//可以在这里定义私有变量和函数
						...
						//添加方法
						o.sayName = function(){ alert(name) };
						//返回对象
						return o;
					}
					var friend = Person("Nicholas", 29, "Software Engineer");
					friend.sayName(); //"Nicholas"
					变量friend 中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。
					稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境——例如，ADsafe（www.adsafe.org）和Caja（http://code.google.com/p/google-caja/）提供的环境——下使用。

			继承
				原型链
					function SuperType(){ this.property = true }
					function SubType(){ this.subproperty = false }
					SubType.prototype = new SuperType()
					...
					实现的本质是重写原型对象，代之以一个新类型的实例。
					换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。
				
					确定原型和实例的关系
						instanceof 操作符
						isPrototypeOf()方法
						alert(instance instanceof Object); 		//true
						alert(instance instanceof SuperType); 	//true
						alert(instance instanceof SubType); 	//true
						只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，所以都会返回 true

					谨慎地定义方法
						继承时，不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。
						就是写在上面 原型链 (...) 的那部分

					原型链的问题
						继承的父级中存在引用类型值的问题
						在创建子类型的实例时，不能向超类型的构造函数中传递参数
				
				借用构造函数
					解决上面 原型链的问题
					function SuperType(){ this.colors = ["red", "blue", "green"] }
					function SubType(){
						// 继承了SuperType
						SuperType.call(this);
					}
					var instance1 = new SubType();

					借用构造函数的问题
						方法都在构造函数中定义，因此函数复用就无从谈起了。

				组合继承
					解决上面 原型链的问题 和 借用构造函数的问题

					function SuperType(name){ this.name = name;this.colors = ["red", "blue", "green"] }
					SuperType.prototype.sayName = function(){ alert(this.name) }
					function SubType(name, age){
						//继承属性
						SuperType.call(this, name);
						this.age = age;
					}
					//继承方法
					SubType.prototype = new SuperType();
					SubType.prototype.constructor = SubType;
					SubType.prototype.sayAge = function(){ alert(this.age) };

					组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点

				原型式继承
					Object.create(a, b) // a 是原型， b 是当前对象的值 (ie9以上可用)
						注意 包含引用类型值的属性始终都会共享相应的值

				寄生式继承
					function createAnother(original){
						var clone = object(original); //通过调用函数创建一个新对象
						clone.sayHi = function(){ //以某种方式来增强这个对象
							alert("hi");
						};
						return clone; //返回这个对象
					}
					var person = {
						name: "Nicholas",
						friends: ["Shelby", "Court", "Van"]
					};
					var anotherPerson = createAnother(person);
					anotherPerson.sayHi(); //"hi"
					统一给对象增加一样的 属性和方法

				寄生组合式继承























原型与闭包
	prototype原型
		每个函数都有一个属性叫做prototype,prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。

	隐式原型__proto__
		每个函数function都有一个prototype，即原型
		每个对象都有一个__proto__，可成为隐式原型
		每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。
		Object.prototype确实一个特例——它的__proto__指向的是null，切记切记！

	还有————函数也是一种对象，函数也有__proto__吗？————当然有
	函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？————Function————注意这个大写的“F”。
	好了，根据上面说的一句话————对象的__proto__指向的是创建它的函数的prototype，就会出现：Object.__proto__ === Function.prototype


	instanceof
		对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，
		但是typeof在判断到引用类型的时候，返回值只有object/function，
		你不知道它到底是一个object对象，还是数组，还是new Number等等。












































