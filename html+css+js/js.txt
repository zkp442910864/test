


js
	技巧
		in 
			判断对象是否包含key 如：'d' in obj
			判断数组是否包含index 如：0 in arr
			返回true，false

		window.parent.document  在iframe里可以获取到父窗口
		window.parent.document.getElementsByTagName('iframe')[0]   在iframe里可以获取到当前iframe

		isNaN() 判断能否转成数值，true 不能， false 可以

		Number()、parseInt()、parseFloat() 把非数值转换为数值

		document.documentElement.scrollTop 获取滚动距离

		当内置的对象自带方法不满足时，可以通过 prototype 原型来给对象添加方法

		Array.isArray(val) 判断 val值 是否数组
	
	语法
		var 关键词来声明变量：var carname;
		全局变量：不要加var

		数据类型：字符串、数字、布尔、数组、对象、Null、Undefined

		函数创建：
			function f(){}
			var f2 = function(){};

		js中的所有事物都是对象,属性和方法是对象的成员，属性是值，方法是执行的动作。
		对象创建：
			var obj = {}
			var obj1 = new Object();
			var obj2 = new f2();

		算术运算符
			+		加
			-		减
			*		乘
			/		除
			%		求余数 (保留整数)
			++		累加
			--		递减

		赋值运算符
			=
			+=
			-=
			*=
			/=
			%=

		比较运算符
			==		等于
			===		全等（值和类型）
			!=		不等于
			>		大于
			<		小于
			>=		大于或等于
			<=		小于或等于

		条件语句	
			if(){} 语句 - 只有当指定条件为 true 时，使用该语句来执行代码
			if(){}else{} 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码
			if(){}else if(){}else{} 语句 - 使用该语句来选择多个代码块之一来执行
			switch 语句 - 使用该语句来选择多个代码块之一来执行
				switch(n){
					case 1:
					  执行代码块 1
					  break;
					case 2:
					  执行代码块 2
					  break;
					default:
					  不匹配执行的代码
				}

		循环
			break 语句用于跳出循环。
			continue 用于跳过循环中的一个迭代。

			for - 循环代码块一定的次数
				for (var i=0;i<cars.length;i++){
					document.write(cars[i] + "<br>");
				}

			for/in - 循环遍历对象的属性
				var person={fname:"John",lname:"Doe",age:25};
				for (x in person){
				  	txt=txt + person[x];
				}

			while - 当指定的条件为 true 时循环指定的代码块,先判断再执行
				while (i<5)
				  	x=x + "The number is " + i + "<br>";
				  	i++;
				}

			do/while - 同样当指定的条件为 true 时循环指定的代码块,先执行再判断
				do{
				  	x=x + "The number is " + i + "<br>";
				  	i++;
				}while (i<5);

		异常错误
			try 语句测试代码块的错误。
			catch 语句处理错误。
				try{
				  	//在这里运行代码
				}catch(err){
				  	//在这里处理错误
				}

			throw 语句创建自定义错误。
				http://www.w3school.com.cn/js/js_errors.asp
				try{
					if(x=="")throw "empty";//这里条件满足，抛出错误
				}catch(err){
					console.log(err);//打印的是empty
				}

	BOM (即 window 对象)
		BOM（浏览器对象模型）
		BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。
		就是浏览器
		
		window 对象
			BOM 的核心对象是 window，它表示浏览器的一个实例。

			全局作用域
				凡是在全局作用域中声明的 变量、函数 都会变成 window 对象的属性和方法。
				全局定义的变量和函数 即 window 上的属性和方法，不能通过 delete 删除，但是直接通过 window['key'] = '' 来定义的可以删除。
					不能删除是因为 描述符configurable 被设置为 false 了。
			
			窗口关系及框架 （基本不用了）
				<frameset rows="160,*">
					<frame src="frame.htm" name="topFrame">
					<frameset cols="50%,50%">
						<frame src="anotherframe.htm" name="leftFrame">
						<frame src="yetanotherframe.htm" name="rightFrame">
					</frameset>
				</frameset>
				top.frames // 貌似被废弃了

			窗口位置
				确定浏览器的位置
					Firefox 不支持下面这两个
					window.screenLeft		浏览器窗口距离左边距离
					window.screenTop		浏览器窗口距离顶部距离

					Safari、Chrome、Firefox 支持一下 api
					window.screenX
					window.screenY

					兼容写法
					var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;
					var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY;
			
			移动窗口
				window.moveTo(x, y)		直接指定位置
				window.moveBy(x, y)		相对位置移动

				这两个方法可能会被浏览器禁用，而且只能对最外层的 window 对象使用。

			窗口大小
				innerWidth和innerHeight 显示的是视口的宽高，outerWidth和outerHeight 显示的是浏览器窗口的宽高 (老版本的chrome，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值)

				window.innerWidth
				window.innerHeight
				window.outerWidth
				window.outerHeight

				ie8之前的版本不支持这些属性，不过，它通过DOM 提供了页面可见区域的相关信息。
				document.documentElement.clientWidth || document.body.clientWidth 		可见宽度
				document.documentElement.clientHeight || document.body.clientHeight		可见高度

				虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小
				兼容例子
					var pageWidth = window.innerWidth,
						pageHeight = window.innerHeight;
					if (typeof pageWidth != "number"){
						if (document.compatMode == "CSS1Compat"){
							pageWidth = document.documentElement.clientWidth;
							pageHeight = document.documentElement.clientHeight;
						} else {
							pageWidth = document.body.clientWidth;
							pageHeight = document.body.clientHeight;
						}
					}

				window.resizeTo(x, y)	设置窗口大小（指定）
				window.resizeBy(x, y)	设置窗口大小（相对）
				这两个方法可能会被浏览器禁用，而且只能对最外层的 window 对象使用。

			导航和打开窗口
				window.open(a, b, c, d)			打开一个窗口
					a：要打开的url
					b：	_self、_parent、_top 		 这三个都是当前页打开
						_blank						会打开新的窗口
						还可以是框架（iframe）的名	  指定 iframe 打开这链接，必须同域名(安全策略的问题)

					c：传递的第二个参数并不是一个已经存在的窗口或框架，可以设置一些属性来定义新开的窗口
							fullscreen 	yes或no 	表示浏览器窗口是否最大化。仅限IE
							height 		数值		表示新窗口的高度。不能小于100
							left 		数值 		表示新窗口的左坐标。不能是负值
							location 	yes或no 	表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器）
							menubar 	yes或no 	表示是否在浏览器窗口中显示菜单栏。默认值为no
							resizable 	yes或no 	表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no
							scrollbars 	yes或no 	表示如果内容在视口中显示不下，是否允许滚动。默认值为no
							status 		yes或no 	表示是否在浏览器窗口中显示状态栏。默认值为no
							toolbar 	yes或no 	表示是否在浏览器窗口中显示工具栏。默认值为no
							top 		数值 		表示新窗口的上坐标。不能是负值
							width 		数值 		表示新窗口的宽度。不能小于100
						var w = window.open("http://www.wrox.com/", "_blank", "height=400,width=400,top=10,left=10,resizable=no,scrollbars=no,status=no,toolbar=no,location=no,menubar=no");
						这里面的属性有可能会被浏览器禁用
					
					调用后会返回当前窗口的对象，可以用来对这窗口进行一些操作
					w.opener	指向创建这窗口的 window
					w.close()	关闭这个创建的窗口
					还可以使用上面的 移动窗口、窗口大小 来对它进行操作
					必须同域名(安全策略的问题)

				弹出窗口屏蔽程序
					被屏蔽后调用 window.open() 会返回 null，但有些浏览器会报错
					try {
						var wroxWin = window.open("http://www.wrox.com", "_blank");
						if (wroxWin == null){
							blocked = true;
						}
					} catch (ex){
						blocked = true;
					}
					if (blocked){
						alert("The popup was blocked!");
					}

			间歇调用和超时调用
				JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码
				为了控制要执行的代码，就有一个JavaScript 任务队列，这些任务会按照将它们添加到队列的顺序执行。
				定时器 到了后会把任务扔到队列中，如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。
				定时器都有一个返回值，用来对它进行取消作用的

				var t = window.setTimeout(function () {}, 1000) 	1秒后执行
				window.clearTimeout(t)		在时间结束前，就能 取消超时调用

				var t = window.setTimeout(function () {}, 1000)		每隔1秒，会执行这函数
				window.clearInterval(t)		把这持续执行的定时器取消

				定时器 里的函数都是在 全局作用域 中执行的，因此 this 指向 window (严格模式 下是 undefined)

				建议用 超时定时器 来模拟 间歇定时器
				原因是后一个 间歇 调用可能会在前一个 间歇 调用结束之前启动。而像示例中那样使用超时调用，则完全可以避免这一点。
				var num = 0;
				var max = 10;
				function incrementNumber() {
					num++;
					//如果执行次数未达到max 设定的值，则设置另一次超时调用
					if (num < max) {
						setTimeout(incrementNumber, 500);
					} else {
						alert("Done");
					}
				}
				setTimeout(incrementNumber, 500);
			系统对话框
				这几个弹窗外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。
				显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。

				window.alert()			提示框
				window.confirm()		警视框，需要确认进行下一步
					if (confirm("Are you sure?")) {
						alert("I'm so glad you're sure! ");
					} else {
						alert("I'm sorry to hear you're not sure. ");
					}
				window.prompt()			一个带文本域的弹窗
					var result = prompt("What is your name? ", "");
					if (result !== null) {
						alert("Welcome, " + result);
					}
				chrome 引入了一种新特性，如果当前脚本在执行过程中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框中都会显示一个复选框，以便用户阻止后续的对话框显示，除非用户刷新页面 (貌似只在移动端出现)

				window.print()		显示“打印”对话框
				window.find()		显示“查找”对话框
				这两个对话框是异步显示的
		
		location 对象
			location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是 document 对象的属性
			window.location === document.location
			也可以直接 location 对象来使用
				hash 		"#contents" 			返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串
				host 		"www.wrox.com:80" 		返回服务器名称和端口号（如果有）
				hostname 	"www.wrox.com" 			返回不带端口号的服务器名称
				href 		"http:/www.wrox.com" 	返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值
				pathname 	"/WileyCDA/" 			返回URL中的目录和（或）文件名
				port 		"8080" 					返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串
				protocol 	"http:" 				返回页面使用的协议。通常是http:或https:
				search 		"?q=javascript" 		返回URL的查询字符串。这个字符串以问号开头

			查询字符串参数
				尽管location.search 返回从问号到URL 末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。
				为此，可以像下面这样创建一个函数，用以解析查询字符串，然后返回包含所有参数的一个对象
				function getQueryStringArgs () {
					//取得查询字符串并去掉开头的问号
					const str = location.search;
					const qs = str.length > 0 ? str.substr(1) : '';

					//没有值就可以直接跳出了，但是为了不报错，就返回个空对象
					if (!qs.length) {
						return {};
					}

					//保存数据的对象
					const args = {};

					//取得每一项
					const items = qs.split('&');

					//逐个将每一项添加到 args 对象中
					for (let i in items) {
						const item = items[i].split('=');
						const name = item[0];
						(name && name.length) && (args[name] = item[1]);
					}

					return args;
				}

			位置操作
				location.assign()		改变浏览器的链接



	DOM (http://www.w3school.com.cn/jsref/dom_obj_all.asp)
		改变 HTML 输出流
			document.write() 可用于直接向 HTML 输出流写内容。

		改变 HTML 元素的样式
			document.getElementById("p2").style.color="blue";

		对象
			document(文档)
				创建新的 HTML 元素
					var para=document.createElement("p");//创建p节点
					var node=document.createTextNode("这是新段落。");//创建文本节点
					para.appendChild(node);//向p里添加文本节点
					parent.removeChild(child);//从父元素中删除子元素

				获取节点
					getElementById() 				通过id获取
					getElementsByName()				通过name值获取，返回的是数组
					getElementsByTagName()			通过标签名获取，返回的是数组
					getAttributeNode()				返回指定的属性节点。
					querySelector()					返回匹配指定 CSS 选择器元素的第一个子元素
					querySelectorAll()				返回匹配指定 CSS 选择器元素的所有子元素节点列表

			元素对象 就是获取到节点后的操作 (节点操作)

				scrollLeft				返回元素左边缘与视图之间的距离。
				scrollTop				返回元素上边缘与视图之间的距离。
				offsetLeft				返回元素的水平偏移位置。
				offsetTop				返回元素的垂直偏移位置。

				clientHeight			返回元素的可见高度。
				clientWidth				返回元素的可见宽度。
				scrollHeight			返回元素的整体高度。
				scrollWidth				返回元素的整体宽度。
				offsetHeight			返回元素的高度。
				offsetWidth				返回元素的宽度。
				offsetParent			返回元素的偏移容器。
				
				hasAttribute			如果元素拥有指定属性，则返回true，否则返回 false。
				hasAttributes			如果元素拥有属性，则返回 true，否则返回 false。
				hasChildNodes			如果元素拥有子节点，则返回 true，否则 false。
				getAttribute			返回元素节点的指定属性值。
				getAttributeNode 		返回指定属性节点
				setAttribute			把指定属性设置或更改为指定值。
				setAttributeNode		设置或更改指定属性节点。
				removeAttribute			从元素中移除指定属性。
				removeAttributeNode		移除指定的属性节点，并返回被移除的节点。
				
				appendChild				向元素添加新的子节点，作为最后一个子节点。
				nextSibling				返回位于相同节点树层级的下一个节点。
				previousSibling			返回位于相同节点树层级的前一个元素。
				insertBefore			在指定的已有的子节点之前插入新节点。
				replaceChild			替换元素中的子节点。

				childNodes				返回元素子节点的 NodeList。是个数组包括文本节点
				children				返回元素子节点,没有其他多余节点
				firstChild				返回元素的首个子。
				lastChild				返回元素的最后一个子元素。
				parentNode				返回元素的父节点。
				removeChild				从元素中移除子节点。

				nodeName				返回元素的标记名（大写）
				nodeType				返回元素的节点类型。(1.元素,3.文本)
				nodeValue				设置或返回元素值。

				className				设置或返回元素的 class 属性。
				classList				返回元素的类名，作为 DOMTokenList 对象。
					add(c1,c2)				在元素中添加一个或多个类名。
					contains()				返回布尔值，判断指定的类名是否存在。
					remove(c1,c2)			移除元素中一个或多个类名。
					toggle(c)				在元素中切换类名。
				id 						设置或返回元素的 id。
				innerHTML				设置或返回元素的内容。
				style					设置或返回元素的 style 属性。
				tabIndex				设置或返回元素的 tab 键控制次序。
				tagName 				返回元素的标签名。
				textContent				设置或返回节点及其后代的文本内容。
				title					设置或返回元素的 title 属性。
				tabIndex				设置或返回元素的标签顺序。
				tagName 				作为一个字符串返回某个元素的标记名（大写）

				cloneNode				克隆元素。

			事件对象
				鼠标事件
					onclick 			当用户点击某个对象时调用的事件句柄。
					ondblclick 			当用户双击某个对象时调用的事件句柄。
					onmousedown			鼠标按钮被按下。
					onmousemove			鼠标被移动。
					onmouseout			鼠标从某元素移开。
					onmouseover			鼠标移到某元素之上。
					onmouseup			鼠标按键被松开。
					onmouseenter		当鼠标指针移动到元素上时触发。
					onmouseleave		当鼠标指针移出元素时触发
					onhover

					属性
						screenX				返回当某个事件被触发时，鼠标指针的水平坐标。
						screenY				返回当某个事件被触发时，鼠标指针的垂直坐标。
						clientX				返回当事件被触发时，鼠标指针的水平坐标。
						clientY				返回当事件被触发时，鼠标指针的垂直坐标。
						key 				在按下按键时返回按键的标识符。
						keyCode				返回键盘事件触发的键的值的字符代码
						which				返回键盘事件触发的键的值的字符代码

				键盘事件
					onkeydown			某个键盘按键被按下
					onkeypress			某个键盘按键被按下并松开。
					onkeyup				某个键盘按键被松开。

				框架/对象（Frame/Object）事件 (页面事件，生命周期)
					onabort				图像的加载被中断。
					onerror				在加载文档或图像时发生错误。
					onload 				一张页面或一幅图像完成加载。
					onpageshow			该事件在用户访问页面时触发
					onpagehide			该事件在用户离开当前网页跳转到另外一个页面时触发
					onunload			用户退出页面。
					onbeforeunload		该事件在即将离开页面（刷新或关闭）时触发
					onhashchange		该事件在当前 URL 的锚部分发生修改时触发。
					onresize			窗口或框架被重新调整大小。
					onscroll			当文档被滚动时发生的事件。  scrollTo(0,0)返回顶部

				表单事件
					onfocus				元素获得焦点。
					onblur				元素失去焦点。
					onchange			域的内容被改变。
					onsubmit			确认按钮被点击。
					oninput				元素获取用户输入时触发
					onpropertychange	同上，兼容ie
					onfocusin			元素即将获取焦点时触发
					onfocusout			元素即将失去焦点时触发 
					onsearch			用户向搜索域输入文本时触发 ( <input="search">)
					onreset				表单重置时触发
					onselect			用户选取文本时触发 ( <input> 和 <textarea>)

				剪贴板事件
					oncopy				该事件在用户拷贝元素内容时触发
					oncut 				该事件在用户剪切元素内容时触发
					onpaste				该事件在用户粘贴元素内容时触发
				
				打印事件
					onafterprint		该事件在页面已经开始打印，或者打印窗口已经关闭时触发
					onbeforeprint		该事件在页面即将开始打印时触发

				拖动事件
					ondrag 				该事件在元素正在拖动时触发
					ondragend			该事件在用户完成元素的拖动时触发
					ondragenter			该事件在拖动的元素进入放置目标时触发
					ondragleave			该事件在拖动元素离开放置目标时触发
					ondragover			该事件在拖动元素在放置目标上时触发
					ondragstart			该事件在用户开始拖动元素时触发
					ondrop				该事件在拖动元素放置在目标区域时触发

				多媒体（Media）事件
					http://www.runoob.com/jsref/dom-obj-event.html (搜：多媒体（Media）事件)

				动画事件
					animationend 		该事件在 CSS 动画结束播放时触发
					animationiteration 	该事件在 CSS 动画重复播放时触发
					animationstart 		该事件在 CSS 动画开始播放时触发

				过渡事件
					transitionend		该事件在 CSS 完成过渡后触发。

				其他事件
					onwheel				该事件在鼠标滚轮在元素上下滚动时触发
					http://www.runoob.com/jsref/dom-obj-event.html (搜：其他事件)

				方法
					addEventListener() 		允许在目标事件中注册监听事件(IE8 = attachEvent())
					removeEventListener()	运行一次注册在事件目标上的监听事件(IE8 = detachEvent())

					阻止事件
						preventDefault()	通知浏览器不要执行与事件关联的默认动作。
						stopPropagation()	不再派发事件。
			
	JavaScript 对象
		Array 对象
			prototype 				允许你向数组对象添加属性或方法。例：Array.prototype.aa = function(){}

			concat()				连接两个或更多的数组，并返回结果
			every()					检测数值元素的每个元素是否都符合条件。例：arr.every(function(a){return a>=1}) 返回true或false
			some()					同上
			filter()				检测数值元素，并返回符合条件所有元素的数组。例：arr.filter(function(a){return a>=1}) 返回新数组
			find()					返回指定的第一个值。例：arr.find(function(a){return a==2}) 当有等于2时，返回所有2中的第一个，否则undefined
			findIndex() 			返回指定值的第一个索引。例：arr.findIndex(function(a){return a==2}) 当有等于2时，返回所有2中的第一个索引，否则-1
			forEach()				数组每个元素都执行一次回调函数。方法用于调用数组的每个元素，并将元素传递给回调函数。例：arr.forEach(function(item,index){console.log(item)})
			indexOf()				搜索数组中的元素，并返回它所在的位置。返回指定值首次出现的索引。例：arr.indexOf("Apple");有则返回索引，否则-1
			lastIndexOf()			基本同上，这是从后面开始。
			join()					把数组的所有元素放入一个字符串，默认以逗号隔开,传参以参数为准。例：arr.join();
			toString()				同上
			valueOf()				同上
			map()					通过指定函数处理数组的每个元素，并返回处理后的数组。
			pop()					删除数组的最后一个元素并返回删除的元素。
			push()					向数组的末尾添加一个或更多元素，并返回新的长度。
			reduce()				将数组元素计算为一个值（从左到右）。例：arr.reduce(function(total, num){return total+num}) 
			reduceRight()			将数组元素计算为一个值（从右到左）。
			reverse()				反转数组的元素顺序。
			shift()					删除并返回数组的第一个元素。
			sort()					对数组的元素进行排序。
				对 进行对象数组排序，可以根据对象里的值进行排序
				var arr = [{a:3},{a:6}];
				arr.sort(function(a,b){
					return a.a > b.a
				})

			splice()				从数组中添加或删除元素,并返回添加或删除的数组给你
				array.splice(index,howmany,item1,.....,itemX)
				index插入的位置，必需
				howmany是否删除当前位置的值，不0，是1，必需
				item1插入的值，可多个，可选
			unshift()				向数组的开头添加一个或更多元素，并返回新的长度。

			以下为 es6

			from 				方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。
				Array.from(arrayLike, x => x * x)
				// 等同于
				Array.from(arrayLike).map(x => x * x)
				Array.from([1, 2, 3], (x) => x * x)

				Array.from({ length: 2 }, () => 'jack')
				// ['jack', 'jack'] 关键在length的长度
			
			of
				Array.of方法用于将一组值，转换为数组。
				Array.of() // []
				Array.of(undefined) // [undefined]
				Array.of(1) // [1]
				Array.of(1, 2) // [1, 2]

			数组实例的 copyWithin()
				数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
				Array.prototype.copyWithin(target, start = 0, end = this.length)
					target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
					start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
					end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

				[1, 2, 3, 4, 5].copyWithin(0, 3)
				// [4, 5, 3, 4, 5]

				// -2相当于3号位，-1相当于4号位,注意：好像要反过来
				[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
				// [4, 2, 3, 4, 5]
			
			数组实例的 fill()
				fill方法使用给定值，填充一个数组, 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。
					['a', 'b', 'c'].fill(7)
					// [7, 7, 7]
					new Array(3).fill(7)
					// [7, 7, 7]

					fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。
					['a', 'b', 'c'].fill(7, 1, 2)
					// ['a', 7, 'c']

					注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。
					let arr = new Array(3).fill([]);
					arr[0].push(5);
					arr
					// [[5], [5], [5]]

			数组实例的 entries()，keys() 和 values() 
				ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。
				它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。
				for (let index of ['a', 'b'].keys()) {
					console.log(index);
				}
				// 0
				// 1

				for (let elem of ['a', 'b'].values()) {
					console.log(elem);
				}
				// 'a'
				// 'b'

				for (let [index, elem] of ['a', 'b'].entries()) {
					console.log(index, elem);
				}
				// 0 "a"
				// 1 "b"

				如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。
				let letter = ['a', 'b', 'c'];
				let entries = letter.entries();
				console.log(entries.next().value); // [0, 'a']
				console.log(entries.next().value); // [1, 'b']
				console.log(entries.next().value); // [2, 'c']

			数组实例的 includes()
				Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。
				[1, 2, 3].includes(2)     // true
				[1, 2, 3].includes(4)     // false
				[1, 2, NaN].includes(NaN) // true

		

		Date 对象
			静态方法
				Date.parse()					接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数
				Date.UTC()						参数分别是 y,m(一月是0，二月是1，以此类推),d,h,m,s, 返回相应日期的毫秒数
																new Date(Date.UTC(2008, 11, 31)).toLocaleDateString()
				Date.now()						取得当前时间的时间戳

			对象上的实例方法
				getFullYear()			从 Date 对象以四位数字返回年份。
				getMonth()				从 Date 对象返回月份 (0 ~ 11)。
				getDate()				从 Date 对象返回一个月中的某一天 (1 ~ 31)。
				getHours()				返回 Date 对象的小时 (0 ~ 23)。
				getMinutes()			返回 Date 对象的分钟 (0 ~ 59)。
				getMilliseconds()		返回 Date 对象的毫秒(0 ~ 999)。

				getDay()				从 Date 对象返回一周中的某一天 (0 ~ 6)。
				getTime()				返回 1970 年 1 月 1 日至今的毫秒数。时间戳
				toISOString()			使用 ISO 标准返回字符串的日期格式。new Date().toISOString();
				toLocaleDateString() 	根据本地时间格式，把 Date 对象的日期部分转换为字符串。new Date().toLocaleDateString();
				toLocaleTimeString()	根据本地时间格式，把 Date 对象的时间部分转换为字符串。new Date().toLocaleTimeString();
				toLocaleString()		据本地时间格式，把 Date 对象转换为字符串。

				setFullYear()			
				setMonth()				
				setDate()				
				setHours()				
				setMinutes()			
				setMilliseconds()
				setTime()

		Math 对象
			http://www.runoob.com/jsref/jsref-obj-math.html
			都是静态属性和方法
			Math.E					自然对数的底数，即常量e的值
			Math.LN10				10的自然对数
			Math.LN2				2的自然对数
			Math.LOG2E				以2为底e的对数
			Math.LOG10E				以10为底e的对数
			Math.PI					π的值
			Math.SQRT1_2			1/2的平方根（即2的平方根的倒数）
			Math.SQRT2				2的平方根

			如果要从数组中找的话，可以用 apply()
				Math.max.apply(Math, [1,2,3,4,56,7])
				Math.max()				返回参数中最大的值
				Math.min()				返回参数中最小的值

			Math.abs(num)			返回num 的绝对值
			Math.asin(x)			返回x 的反正弦值
			Math.exp(num)			返回Math.E 的num 次幂
			Math.atan(x)			返回x 的反正切值
			Math.log(num)			返回num 的自然对数
			Math.atan2(y,x)			返回y/x 的反正切值
			Math.pow(num,power)		返回num 的power 次幂
			Math.cos(x)				返回x 的余弦值
			Math.sqrt(num)			返回num 的平方根
			Math.sin(x)				返回x 的正弦值
			Math.acos(x)			返回x 的反余弦值
			Math.tan(x)				返回x 的正切值
			
			Math.ceil(x)			对数进行上舍入。
			Math.floor(x)			对 x 进行下舍入。
			Math.round(x)			把数四舍五入为最接近的整数。
			Math.random()			返回 0 ~ 1 之间的随机数。
				Math.floor(Math.random() * 8 + 2) // 获取 2-8 之间的数，通过修改2和8，来改范围

		Number 对象
			http://www.runoob.com/jsref/jsref-obj-number.html
			toFixed(x)				指定小数为x位。
			toExponential(x)		指定小数为x位,带e表示
			toPrecision()

		String 对象
			http://www.runoob.com/jsref/jsref-obj-string.html
			String.fromCharCode()	静态方法，把 ascii码 转换为字符串

			charAt()				返回在指定位置的字符。
			charCodeAt() 			返回在指定的位置的字符的 Unicode 编码。
			concat()				连接两个或更多字符串，并返回新的字符串。

			第一个参数是查找的字符串，第二个参数都是指定开始的位置
				indexOf()				头开始，返回指定字符串第一次出现的索引，没有返回-1
				lastIndexOf()			基本同上，尾开始

			以下三个都是截取字符串，并返回
				传入的负值与字符串的长度相加，得到的位置index
				slice()					提取字符串的片断，并在新的字符串中返回被提取的部分。例：str.slice(1,5);
				substring(s,e)			基本同上。所有负值转化为 0
				substr(s,e)				基本同上。e指定的是个数(当为负时转化为 0)	版本 < ie9 传负值有问题
					var stringValue = "hello world";
					alert(stringValue.substr(3, 7)); 	//"lo worl"


			

			toLowerCase()			把字符串转换为小写。
			toLocaleLowerCase()		基本同上，针对地区的(使用针对地区的方法更稳妥一些)。
			toUpperCase()			把字符串转换为大写。
			toLocaleUpperCase()		基本同上，针对地区的(使用针对地区的方法更稳妥一些)。

			trim()					去除字符串两边的空白,并返回新的值
			trimLeft()				基本同上，去掉左边的
			trimRight()				基本同上，去掉右边的

			localeCompare()			比较字符串，判断在当前字符串的前后或相等
				var stringValue = "yellow";
				alert(stringValue.localeCompare("brick")); //前 1
				alert(stringValue.localeCompare("yellow")); //相等 0
				alert(stringValue.localeCompare("zoo")); //后 -1

			一下是支持正则表达式的 String 对象的方法
				replace()				在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串。例：str.replace(/^\s+|\s+$/g, '')
				match()					查找找到一个或多个正则表达式的匹配。例：str.match(/ain/g);
				search()				查找与正则表达式相匹配的值。
				split()					把字符串分割为数组并返回。第一个参数 分隔符，第二个参数 可以指定返回数据的 length  < ie8 有问题

		RegExp 对象 正则
			静态属性
				RegExp.input			最近一次要匹配的字符串
				RegExp.leftContext		最近一次的匹配项
				RegExp.rightContext		Input字符串中lastMatch之后的文本
				RegExp.lastMatch		最近一次的匹配项
				RegExp.lastParen		最近一次匹配的捕获组
				RegExp.multiline		布尔值，表示是否所有表达式都使用多行模式
				RegExp.$1				RegExp.$1、RegExp.$2...RegExp.$9，分别用于存储第一、第二...第九个匹配的捕获组

			实例方法
				toString()			返回正则表达式字符串
				toLocaleString()	返回正则表达式字符串
				valueOf()	返回正则表达式本身
				test() 		检索字符串中指定的值,返回 true 或 false。(验证)，例子: /^\s+|\s+$/g.test(str)
				exec()		检索字符串中指定的值。返回找到的值。例子: str = "Visit W3School"; /W3School/g.exec(str)

			/pattern(表达式)/flags(标志)
				3 个标志 (可组合使用)
					g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
					i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
					m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

					var pattern1 = /\[bc\]at/i;
						// 做判断
						alert(pattern1.global); //false
						alert(pattern1.ignoreCase); //true
						alert(pattern1.multiline); //false
						alert(pattern1.lastIndex); //0
						alert(pattern1.source); //"\[bc\]at"

		Function 对象
			函数声明
				率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；(相当于var的提升作用域)
					function f(){}

			函数表达式
				至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行 (匿名函数)
					var f = function () {}

			在函数内部，有两个特殊的对象：arguments 和 this (严格模式下不能使用)
				arguments			包含所有参数的数组
				arguments.callee	指向自身的函数
					严格模式下 解决方案
					(function () {}) 在括号里声明函数，不影响全局，一个闭包函数 (闭包不要用箭头函数)
					var factorial = (function f (num) {
						if (num <= 1) {
							return 1;
						} else {
							return num * f(num-1);
						}
					});

			每个JavaScript函数都会有很多 附属 静态属性和方法
				name 			获取当前函数的 方法名
				caller			这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null
					function outer(){inner()};function inner(){alert(inner.caller)};outer();
					
				toString()		获取当前函数体的 字符串
				call()	 		方法会用它的第一个参数 作为 当前调用call()函数的this指针  例子:var obj={} f.call(obj)
				apply() 		apply()和call()类似的，只是apply()要求第二个参数必须是一个数组。
					这个数组会作为参数传递给目标函数，通过arguments数组来获取  例子:var obj={} f.apply(obj,['q','b','c'])
				
		
		Global 对象
			一个虚拟的对象，其实就是 window (自己的理解)
			var global = function(){return this;}(); // 手动创建 global 对象

			isNaN()
			isFinite()
			parseInt()
			parseFloat()

			编码
				encodeURI()					对链接的中文、空格进行转义 转成: %A4%AB
				encodeURIComponent()		对链接的符号和中文、空格进行转义 转成: %A4%AB

			解码
				decodeURI()					对应 encodeURI()，把编码转回原样
				decodeURIComponent()		对应 encodeURIComponent()，把编码转回原样

			eval()			解析字符串的JavaScript (要小心代码注入)
		
		Object 对象
			对象的高级操作
				属性类型
					1.数据属性，4个属性描述符
						configurable 		判断 能否使用 delete 删除，默认 ture，(设置为 false，严格模式下进行删除会报错)(设置为 false 后，其它的描述符不能在进行修改)
						enumerable	 		判断 是否循环改属性，默认 true
						writable			判断 能否修改改属性，默认 true，(设置为 false，严格模式下进行修改会报错)
						value				属性值，读取写入都是对改描述进行操作，默认 undefined

						使用 Object.defineProperty(a, b, c) 可以进行修改，a 对象、b Key值、c 要修改的描述符对象 (ie8 不要使用)
							var person = { name: 'Nicholas' };
							Object.defineProperty(person, 'name', { writable: false });
					
					2.访问器属性
						一对 getter 和 setter 函数 (不必要的，要做拦截操作可以定义来处理数据，严格模式下必须一对一起定义)
						对取值时调用 getter
						修改值时调用 setter
						4个描述符
							configurable		同上
							enumerable			同上
							get					在读取属性时调用的函数，默认值为undefined
							set					在写入属性时调用的函数，默认值为undefined

							同样必须用 Object.defineProperty() 来定义
								Object.defineProperty(person, 'name', {
									get () {...},
									set (nVal) {...}
								});
						
						ie9 才实现，旧的使用 __defineGetter__() 和 __defineSetter__()
							person.__defineGetter__('name', function () {})
							person.__defineSetter__('name', function (nVal) {})

				定义多个属性
					为对象定义多个属性的可能性很大，又定义了一个 Object.defineProperties(a, b) 方法，利用这个方法可以通过描述符一次定义多个属性。
					var person = {};
					Object.defineProperties(person, {
						name: { value: 'abc' },
						name2: { value: 'abc' },
						name3: {
							get () {},
							set (nVal) {}
						}
					})

				读取属性的特性
					Object.getOwnPropertyDescriptor(a, b) 读取对象里属性的描述，a 对象， b 对象里的Key (ie9 以上可使用)
						var person = {name: 'asdf'}
						Object.getOwnPropertyDescriptor(person, 'name')
			
			模式 (设计模式)
				工厂模式 (我的理解：就是封装公共的部分)
					工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。

					function createPerson(name, age, job){
						var o = new Object();
						o.name = name;o.age = age;o.job = job;
						o.sayName = function(){
							alert(this.name);
						};
						return o;
					}

				构造函数模式
					构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new 操作符。
					不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。
					由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。

					function Person(name, age, job){
						this.name = name;this.age = age;this.job = job;
						this.sayName = function(){
							alert(this.name);
						};
					}
					var p = new Person("Greg", 27, "Doctor");

					p 有一个 constructor（构造函数）属性，该属性指向 Person
					对象的 constructor 属性最初是用来标识对象类型的，但是 instanceof 操作符要更可靠一些

					所有创建的对象既是 Object 的实例
					也是实例者(Person)的对象，是因为所有对象均继承自 Object

				原型模式
					每个函数都有一个 prototype（原型）属性，是一个指针，指向一个对象。
					用途是共享所有实例的属性和方法，这就解决了上面的设计模式存在的一个问题(通过 this 创建的引用类型，每次实例会产生新的内存空间)。

						原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。
						组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。

						function Person () {}
						Person.prototype.name = "Nicholas";
						Person.prototype.age = 29;
						Person.prototype.job = "Software Engineer";
						Person.prototype.sayName = function(){ alert(this.name) };
						var p = new Person();

						更简单的原型语法
						Person.prototype = {
							name : "Nicholas",
							age : 29,
							job: "Software Engineer",
							sayName : function () {
								alert(this.name);
							},
							/* 这种字面量写法会导致 Person.prototype.constructor 指向 Object，这是解决方法
							 * 缺点：导致它的 enumerable 描述符 被设置为true，可以使用 Object.defineProperty() 修改为false
							*/
							constructor : Person 
						};

					所有的实例对象都有一个 __proto__ 属性，指向实例函数的 prototype (也是构造函数的原型)
					当读取对象的某个属性时，先从当前 对象 找，找不到再从 对象的原型 里面找。而这正是 多个对象实例 共享原型 所保存的属性和方法的基本原理。
					原型的动态性(这里需要注意)
						Person.prototype 是个指针
						p.__proto__ 	 也是个指针
						在实例化对象后可以对 prototype 进行修改，但不能使用 字面量方法赋值对象

					isPrototypeOf()
						用来确定对象之间是否存在关系
						alert(Person.prototype.isPrototypeOf(p)); //true
					
					Object.getPrototypeOf() (ie9以上可用)
						这个方法返回 __proto__ 的值
						alert(Object.getPrototypeOf(p) === Person.prototype);

					hasOwnProperty()
						检测一个属性是存在于实例中，还是存在于原型中。在实例中返回 true
						alert(p.hasOwnProperty("name")); //false

					in 操作符
						'name' in p // 不管属性名在实例或者原型中，只要有就返回 true
						同时使用 hasOwnProperty() 方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。(因为 hasOwnProperty 在原型中找不到也是返回 false)
						function hasPrototypeProperty (object, name) { return !object.hasOwnProperty(name) && (name in object) }

					Object.keys()
						返回一个包含所有可枚举属性的字符串数组
						Object.keys(p)

					Object.getOwnPropertyNames()
						返回一个所有属性名的数组，无论它是否可枚举
						Object.getOwnPropertyNames(Person.prototype)

					原生对象的原型 (不推荐修改)
						原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。
						原生引用类型(Object、Array、String，等等).prototype = function () {...}

				组合使用 构造函数模式 和 原型模式 (用最广泛、认同度最高的一种创建自定义类型的方法)
					构造函数实现 私有数据
					原型模式实现 共享数据
					function Person(name, age, job){
						this.name = name;this.age = age;
						this.job = job;this.friends = ["Shelby", "Court"];
					}
					Person.prototype = {
						constructor : Person,
						sayName : function () { alert(this.name) }
					}

				动态原型模式
					function Person(name, age, job){
						//属性
						this.name = name;this.age = age;this.job = job;
						//方法
						if (typeof this.sayName != "function"){
							Person.prototype.sayName = function(){ alert(this.name) };
						}
					}

				寄生构造函数模式
					function SpecialArray(){
						//创建数组
						var values = new Array();
						//添加值
						values.push.apply(values, arguments);
						//添加方法
						values.toPipedString = function(){ return this.join("|") };
						//返回数组
						return values;
					}
					var colors = new SpecialArray("red", "blue", "green");
					alert(colors.toPipedString()); //"red|blue|green"
				
				稳妥构造函数模式
					function Person(name, age, job){
						//创建要返回的对象
						var o = new Object();
						//可以在这里定义私有变量和函数
						...
						//添加方法
						o.sayName = function(){ alert(name) };
						//返回对象
						return o;
					}
					var friend = Person("Nicholas", 29, "Software Engineer");
					friend.sayName(); //"Nicholas"
					变量friend 中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。
					稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境——例如，ADsafe（www.adsafe.org）和Caja（http://code.google.com/p/google-caja/）提供的环境——下使用。

			继承
				原型链
					function SuperType(){ this.property = true }
					function SubType(){ this.subproperty = false }
					SubType.prototype = new SuperType()
					...
					实现的本质是重写原型对象，代之以一个新类型的实例。
					换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。
				
					确定原型和实例的关系
						instanceof 操作符
						isPrototypeOf()方法
						alert(instance instanceof Object); 		//true
						alert(instance instanceof SuperType); 	//true
						alert(instance instanceof SubType); 	//true
						只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，所以都会返回 true

					谨慎地定义方法
						继承时，不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。
						就是写在上面 原型链 (...) 的那部分

					原型链的问题
						继承的父级中存在引用类型值的问题
						在创建子类型的实例时，不能向超类型的构造函数中传递参数
				
				借用构造函数
					解决上面 原型链的问题
					function SuperType(){ this.colors = ["red", "blue", "green"] }
					function SubType(){
						// 继承了SuperType
						SuperType.call(this);
					}
					var instance1 = new SubType();

					借用构造函数的问题
						方法都在构造函数中定义，因此函数复用就无从谈起了。

				组合继承
					解决上面 原型链的问题 和 借用构造函数的问题

					function SuperType(name){ this.name = name;this.colors = ["red", "blue", "green"] }
					SuperType.prototype.sayName = function(){ alert(this.name) }
					function SubType(name, age){
						//继承属性
						SuperType.call(this, name);
						this.age = age;
					}
					//继承方法
					SubType.prototype = new SuperType();
					SubType.prototype.constructor = SubType;
					SubType.prototype.sayAge = function(){ alert(this.age) };

					组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点

				原型式继承
					原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。
					而复制得到的副本还可以得到进一步改造。

					Object.create(a, b) // a 是原型， b 是当前对象的值 (ie9以上可用)
						注意 包含引用类型值的属性始终都会共享相应的值

				寄生式继承
					寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。
					为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。

					function createAnother(original){
						var clone = Object(original); //通过调用函数创建一个新对象
						clone.sayHi = function(){ //以某种方式来增强这个对象
							alert("hi");
						};
						return clone; //返回这个对象
					}
					var person = {
						name: "Nicholas",
						friends: ["Shelby", "Court", "Van"]
					};
					var anotherPerson = createAnother(person);
					anotherPerson.sayHi(); //"hi"
					统一给对象增加一样的 属性和方法

				寄生组合式继承
					寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。
					
					function inheritPrototype(subType, superType){
						var prototype = Object(superType.prototype); //创建对象
						prototype.constructor = subType; //增强对象
						subType.prototype = prototype; //指定对象
					}
					function SuperType(name){
						this.name = name;
						this.colors = ["red", "blue", "green"];
					}
					SuperType.prototype.sayName = function(){
						alert(this.name);
					};
					function SubType(name, age){
						SuperType.call(this, name);
						this.age = age;
					}
					inheritPrototype(SubType, SuperType);
					SubType.prototype.sayAge = function(){
						alert(this.age);
					};
					这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的、多余的属性。

				小结
					原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。
	
	函数表达式
		var f = function () {}
		(function () {})
		递归
		闭包 (有必要重看 7.2)
			了解
				1.执行环境
					在每个函数调用的时候会创建一个 执行环境
				2.作用域链
					在创建 执行环境 后，会有对应的作用域，通过函数的 [[Scopes]] 指向 全局环境对象(this) 和 包含函数参数的 活动对象(arguments)
					从函数里层向外扩展 0、1、2、3、4...
					在 全局环境 中调用函数(指的是普通的函数)，函数位于 1 的位置
				3.销毁
					一般来讲，当函数执行完毕后，执行环境 和 局部活动对象 就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。
			
			当执行的函数，返回一个匿名函数时
				function child () {
					return function () {
						...
					}
				}
				var a = child();
				a();
				a = null;
				会按上面的步骤走完，但在第三步时，执行完后 局部活动对象，因为返回 匿名函数 且被 a 引用，所以不会被销毁。 
				当调用 a 函数时，在上面第二步的 作用域链 是这样的，闭包的活动对象、child 的活动对象、全局环境对象
				设置为等于 null 解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域（除了全局作用域）也都可以安全地销毁了。

			由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。
			过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。
			虽然像 V8 等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但请大家还是要慎重使用闭包。

			关于this对象

			内存泄漏
				由于IE9 之前的版本对JScript 对象和COM 对象使用不同的垃圾收集例程，因此闭包在IE 的这些版本中会导致一些特殊的问题。
					function assignHandler(){
						var element = document.getElementById("someElement");
						element.onclick = function(){
							alert(element.id);
						};
					}
					因为函数中存在匿名函数，会导致匿名函数的活动对象不会被销毁，每次使用事件都会触发对 element 的引用

					function assignHandler(){
						var element = document.getElementById("someElement");
						var id = element.id;
						element.onclick = function(){
							alert(id);
						};
						element = null;
					}
					这样修改后
						1.赋值给变量后减少了对 element 的引用
						2.然后 element 不使用后，赋值为 null
						3.这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。

			只要函数中存在匿名函数，并被使用着，这就是闭包。

		模仿块级作用域
			对于 var 来说
				JavaScript 没有块级作用域的概念
				这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。(就是 var 的提升作用域问题)
					function outputNumbers(count){
						for (var i=0; i < count; i++){
							alert(i);
						}
						var i; //重新声明变量
						alert(i); //计数
					}
					等于
					function outputNumbers(count){
						var i;
						for (i=0; i < count; i++){
							alert(i);
						}
						var i; //重新声明变量 (会被无视)
						// var i = 10; 这种会被执行
						alert(i); //计数
					}
				JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。

			模拟块级作用域 (私有作用域) (解决多人开发明命冲突问题)
				(function () {})()
				把函数声明 转 函数表达式，只需在函数前后加对括号，之后只要在后面加对括号就马上执行了

				这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。

		私有变量
			就是函数中可访问，外部不能访问。
			但可以通过定义 特权方法，就是让内部参数能被外部访问。
				function Person(name){
					this.getName = function(){return name;};
					this.setName = function (value) {name = value;};
				}
				var person = new Person("Nicholas");
				alert(person.getName()); //"Nicholas"
				person.setName("Greg");
				alert(person.getName()); //"Greg"

				这样私有变量只能通过特权方法来进行操作。

			静态私有变量
			模块模式
			增强的模块模式
























原型与闭包
	prototype原型
		每个函数都有一个属性叫做prototype,prototype的属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。

	隐式原型__proto__
		每个函数function都有一个prototype，即原型
		每个对象都有一个__proto__，可成为隐式原型
		每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。
		Object.prototype确实一个特例——它的__proto__指向的是null，切记切记！

	还有————函数也是一种对象，函数也有__proto__吗？————当然有
	函数也不是从石头缝里蹦出来的，函数也是被创建出来的。谁创建了函数呢？————Function————注意这个大写的“F”。
	好了，根据上面说的一句话————对象的__proto__指向的是创建它的函数的prototype，就会出现：Object.__proto__ === Function.prototype


	instanceof
		对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，
		但是typeof在判断到引用类型的时候，返回值只有object/function，
		你不知道它到底是一个object对象，还是数组，还是new Number等等。












































