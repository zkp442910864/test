https://mp.weixin.qq.com/s?__biz=MzIxNDc4MjEzNw==&mid=2247484346&idx=1&sn=ca9c3c752c96ce99f5370919ac3354bb&chksm=97a31a6ca0d4937abb4c446498c29ab380d486c141cf0a937124c2d5aa2eb54030e9305b5ef9&token=866091504&lang=zh_CN#rd


无状态组件 和 有状态组件
    有状态组件，除了当前组件的初始化，会有额外的开销，子组件的递归初始化过程。
    无状态组件，这种并非真正的组件，理解成一个代码片段，只有当前组件的初始化，没有子组件的递归初始化过程，所以开销会低很多。

vue 的更新是组件粒度
    父组件的内容发生改变，导致的重新渲染，子组件中不会重新渲染（子组件不被父组件影响的情况下）
    理解成，组件的影响范围，粒度越小影响的就越小，反之越大。

vue 局部变量
    在组件中每一次 this.xxx 都会触发组件的依赖收集相关逻辑，次数执行多的情况下，会影响到性能下降。
    计算属性可以通过传入参数获取最新值
    所以面对循环相关的，先获取值，再进行使用。

计算量大的组件，巧用 v-show 代替 v-if
    v-if 指令在编译阶段就会编译成一个三元运算符
    v-if 渲染的节点，由于新旧节点 vnode 不一致，在核心 diff 算法比对过程中，会移除旧的 vnode 节点，创建新的 vnode 节点
    因此使用 v-if 每次更新组件都会创建新的子组件，当更新的组件多了，自然就会造成性能压力。
    所以这里使用 v-show 性能会更好点

Deferred features 延迟渲染
    当一次性渲染内容过多的时候，可以采用分批渲染

Time slicing 时间片切割技术
    一个长列表，切割渲染，延时渲染
    就是把一次性渲染的数据，分批渲染，同延迟渲染

Non-reactive data 数据非双向绑定
    可以通过 Object 的函数修改描述符 enumerable 为 false 使参数不可遍历，达到这效果

Virtual scrolling 虚拟滚动
