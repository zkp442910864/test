


js （大部分api 在js.txt 里）
	语法
		var 关键词来声明变量：var carname;
		全局变量：不要加var

		数据类型：字符串、数字、布尔、数组、对象、Null、Undefined

		函数创建：
			function f(){}
			var f2 = function(){};

		js中的所有事物都是对象,属性和方法是对象的成员，属性是值，方法是执行的动作。
		对象创建：
			var obj = {}
			var obj1 = new Object();
			var obj2 = new f2();

		算术运算符
			+		加
			-		减
			*		乘
			/		除
			%		求余数 (保留整数)
			++		累加
			--		递减

		赋值运算符
			=
			+=
			-=
			*=
			/=
			%=

		比较运算符
			==		等于
			===		全等（值和类型）
			!=		不等于
			>		大于
			<		小于
			>=		大于或等于
			<=		小于或等于

		条件语句	
			if(){} 语句 - 只有当指定条件为 true 时，使用该语句来执行代码
			if(){}else{} 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码
			if(){}else if(){}else{} 语句 - 使用该语句来选择多个代码块之一来执行
			switch 语句 - 使用该语句来选择多个代码块之一来执行
				switch(n){
					case 1:
					  执行代码块 1
					  break;
					case 2:
					  执行代码块 2
					  break;
					default:
					  不匹配执行的代码
				}

		循环
			break 语句用于跳出循环。
			continue 用于跳过循环中的一个迭代。

			for - 循环代码块一定的次数
				for (var i=0;i<cars.length;i++){
					document.write(cars[i] + "<br>");
				}

			for/in - 循环遍历对象的属性
				var person={fname:"John",lname:"Doe",age:25};
				for (x in person){
				  	txt=txt + person[x];
				}

			while - 当指定的条件为 true 时循环指定的代码块,先判断再执行
				while (i<5)
				  	x=x + "The number is " + i + "<br>";
				  	i++;
				}

			do/while - 同样当指定的条件为 true 时循环指定的代码块,先执行再判断
				do{
				  	x=x + "The number is " + i + "<br>";
				  	i++;
				}while (i<5);

		异常错误
			try 语句测试代码块的错误。
			catch 语句处理错误。
				try{
				  	//在这里运行代码
				}catch(err){
				  	//在这里处理错误
				}

			throw 语句创建自定义错误。
				http://www.w3school.com.cn/js/js_errors.asp
				try{
					if(x=="")throw "empty";//这里条件满足，抛出错误
				}catch(err){
					console.log(err);//打印的是empty
				}

			
	JavaScript 对象
		值类型 String、Number、Boolean、undefined、null
		引用类型 Objec、Array、Date、RegExp、Function

		Array 对象
		Date 对象
		Math 对象
		Number 对象

		String 对象
			
		RegExp 对象 正则
			
		Function 对象
			函数声明
				率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；(相当于var的提升作用域)
					function f(){}

			函数表达式
				至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行 (匿名函数)
					var f = function () {}

			在函数内部，有两个特殊的对象：arguments 和 this (严格模式下不能使用)
				arguments			包含所有参数的数组
				arguments.callee	指向自身的函数
					严格模式下 解决方案
					(function () {}) 在括号里声明函数，不影响全局，一个闭包函数 (闭包不要用箭头函数)
					var factorial = (function f (num) {
						if (num <= 1) {
							return 1;
						} else {
							return num * f(num-1);
						}
					});

			每个JavaScript函数都会有很多 附属 静态属性和方法
				name 			获取当前函数的 方法名
				caller			这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null
					function outer(){inner()};function inner(){alert(inner.caller)};outer();
					
				toString()		获取当前函数体的 字符串
				call()	 		方法会用它的第一个参数 作为 当前调用call()函数的this指针  例子:var obj={} f.call(obj)
				apply() 		apply()和call()类似的，只是apply()要求第二个参数必须是一个数组。
					这个数组会作为参数传递给目标函数，通过arguments数组来获取  例子:var obj={} f.apply(obj,['q','b','c'])
				
		
		Global 对象
			一个虚拟的对象，其实就是 window (自己的理解)
			var global = function(){return this;}(); // 手动创建 global 对象
		
		Object 对象
			对象的高级操作
				属性类型
					1.数据属性，4个属性描述符
						configurable 		判断 能否使用 delete 删除，默认 ture，(设置为 false，严格模式下进行删除会报错)(设置为 false 后，其它的描述符不能在进行修改)
						enumerable	 		判断 是否循环改属性，默认 true
						writable			判断 能否修改改属性，默认 true，(设置为 false，严格模式下进行修改会报错)
						value				属性值，读取写入都是对改描述进行操作，默认 undefined

						使用 Object.defineProperty(a, b, c) 可以进行修改，a 对象、b Key值、c 要修改的描述符对象 (ie8 不要使用)
							var person = { name: 'Nicholas' };
							Object.defineProperty(person, 'name', { writable: false });
					
					2.访问器属性
						一对 getter 和 setter 函数 (不必要的，要做拦截操作可以定义来处理数据，严格模式下必须一对一起定义)
						对取值时调用 getter
						修改值时调用 setter
						4个描述符
							configurable		同上
							enumerable			同上
							get					在读取属性时调用的函数，默认值为undefined
							set					在写入属性时调用的函数，默认值为undefined

							同样必须用 Object.defineProperty() 来定义
								Object.defineProperty(person, 'name', {
									get () {...},
									set (nVal) {...}
								});
						
						ie9 才实现，旧的使用 __defineGetter__() 和 __defineSetter__()
							person.__defineGetter__('name', function () {})
							person.__defineSetter__('name', function (nVal) {})

				定义多个属性
					为对象定义多个属性的可能性很大，又定义了一个 Object.defineProperties(a, b) 方法，利用这个方法可以通过描述符一次定义多个属性。
					var person = {};
					Object.defineProperties(person, {
						name: { value: 'abc' },
						name2: { value: 'abc' },
						name3: {
							get () {},
							set (nVal) {}
						}
					})

				读取属性的特性
					Object.getOwnPropertyDescriptor(a, b) 读取对象里属性的描述，a 对象， b 对象里的Key (ie9 以上可使用)
						var person = {name: 'asdf'}
						Object.getOwnPropertyDescriptor(person, 'name')
			
			模式 (设计模式)
				工厂模式 (我的理解：就是封装公共的部分)
					工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。

					function createPerson(name, age, job){
						var o = new Object();
						o.name = name;o.age = age;o.job = job;
						o.sayName = function(){
							alert(this.name);
						};
						return o;
					}

				构造函数模式
					构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new 操作符。
					不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。
					由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。

					function Person(name, age, job){
						this.name = name;this.age = age;this.job = job;
						this.sayName = function(){
							alert(this.name);
						};
					}
					var p = new Person("Greg", 27, "Doctor");

					p 有一个 constructor（构造函数）属性，该属性指向 Person
					对象的 constructor 属性最初是用来标识对象类型的，但是 instanceof 操作符要更可靠一些

					所有创建的对象既是 Object 的实例
					也是实例者(Person)的对象，是因为所有对象均继承自 Object

				原型模式
					每个函数都有一个 prototype（原型）属性，是一个指针，指向一个对象。
					用途是共享所有实例的属性和方法，这就解决了上面的设计模式存在的一个问题(通过 this 创建的引用类型，每次实例会产生新的内存空间)。

						原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。
						组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。

						function Person () {}
						Person.prototype.name = "Nicholas";
						Person.prototype.age = 29;
						Person.prototype.job = "Software Engineer";
						Person.prototype.sayName = function(){ alert(this.name) };
						var p = new Person();

						更简单的原型语法
						Person.prototype = {
							name : "Nicholas",
							age : 29,
							job: "Software Engineer",
							sayName : function () {
								alert(this.name);
							},
							/* 这种字面量写法会导致 Person.prototype.constructor 指向 Object，这是解决方法
							 * 缺点：导致它的 enumerable 描述符 被设置为true，可以使用 Object.defineProperty() 修改为false
							*/
							constructor : Person 
						};

					所有的实例对象都有一个 __proto__ 属性，指向实例函数的 prototype (也是构造函数的原型)
					当读取对象的某个属性时，先从当前 对象 找，找不到再从 对象的原型 里面找。而这正是 多个对象实例 共享原型 所保存的属性和方法的基本原理。
					原型的动态性(这里需要注意)
						Person.prototype 是个指针
						p.__proto__ 	 也是个指针
						在实例化对象后可以对 prototype 进行修改，但不能使用 字面量方法赋值对象

					isPrototypeOf()
						用来确定对象之间是否存在关系
						alert(Person.prototype.isPrototypeOf(p)); //true
					
					Object.getPrototypeOf() (ie9以上可用)
						这个方法返回 __proto__ 的值
						alert(Object.getPrototypeOf(p) === Person.prototype);

					hasOwnProperty()
						检测一个属性是存在于实例中，还是存在于原型中。在实例中返回 true
						alert(p.hasOwnProperty("name")); //false

					in 操作符
						'name' in p // 不管属性名在实例或者原型中，只要有就返回 true
						同时使用 hasOwnProperty() 方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。(因为 hasOwnProperty 在原型中找不到也是返回 false)
						function hasPrototypeProperty (object, name) { return !object.hasOwnProperty(name) && (name in object) }

					Object.keys()
						返回一个包含所有可枚举属性的字符串数组
						Object.keys(p)

					Object.getOwnPropertyNames()
						返回一个所有属性名的数组，无论它是否可枚举
						Object.getOwnPropertyNames(Person.prototype)

					原生对象的原型 (不推荐修改)
						原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。
						原生引用类型(Object、Array、String，等等).prototype = function () {...}

				组合使用 构造函数模式 和 原型模式 (用最广泛、认同度最高的一种创建自定义类型的方法)
					构造函数实现 私有数据
					原型模式实现 共享数据
					function Person(name, age, job){
						this.name = name;this.age = age;
						this.job = job;this.friends = ["Shelby", "Court"];
					}
					Person.prototype = {
						constructor : Person,
						sayName : function () { alert(this.name) }
					}

				动态原型模式
					function Person(name, age, job){
						//属性
						this.name = name;this.age = age;this.job = job;
						//方法
						if (typeof this.sayName != "function"){
							Person.prototype.sayName = function(){ alert(this.name) };
						}
					}

				寄生构造函数模式
					function SpecialArray(){
						//创建数组
						var values = new Array();
						//添加值
						values.push.apply(values, arguments);
						//添加方法
						values.toPipedString = function(){ return this.join("|") };
						//返回数组
						return values;
					}
					var colors = new SpecialArray("red", "blue", "green");
					alert(colors.toPipedString()); //"red|blue|green"
				
				稳妥构造函数模式
					function Person(name, age, job){
						//创建要返回的对象
						var o = new Object();
						//可以在这里定义私有变量和函数
						...
						//添加方法
						o.sayName = function(){ alert(name) };
						//返回对象
						return o;
					}
					var friend = Person("Nicholas", 29, "Software Engineer");
					friend.sayName(); //"Nicholas"
					变量friend 中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。
					稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境——例如，ADsafe（www.adsafe.org）和Caja（http://code.google.com/p/google-caja/）提供的环境——下使用。

			继承
				原型链
					function SuperType(){ this.property = true }
					function SubType(){ this.subproperty = false }
					SubType.prototype = new SuperType()
					...
					实现的本质是重写原型对象，代之以一个新类型的实例。
					换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。
				
					确定原型和实例的关系
						instanceof 操作符
						isPrototypeOf()方法
						alert(instance instanceof Object); 		//true
						alert(instance instanceof SuperType); 	//true
						alert(instance instanceof SubType); 	//true
						只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，所以都会返回 true

					谨慎地定义方法
						继承时，不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。
						就是写在上面 原型链 (...) 的那部分

					原型链的问题
						继承的父级中存在引用类型值的问题
						在创建子类型的实例时，不能向超类型的构造函数中传递参数
				
				借用构造函数
					解决上面 原型链的问题
					function SuperType(){ this.colors = ["red", "blue", "green"] }
					function SubType(){
						// 继承了SuperType
						SuperType.call(this);
					}
					var instance1 = new SubType();

					借用构造函数的问题
						方法都在构造函数中定义，因此函数复用就无从谈起了。

				组合继承
					解决上面 原型链的问题 和 借用构造函数的问题

					function SuperType(name){ this.name = name;this.colors = ["red", "blue", "green"] }
					SuperType.prototype.sayName = function(){ alert(this.name) }
					function SubType(name, age){
						//继承属性
						SuperType.call(this, name);
						this.age = age;
					}
					//继承方法
					SubType.prototype = new SuperType();
					SubType.prototype.constructor = SubType;
					SubType.prototype.sayAge = function(){ alert(this.age) };

					组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点

				原型式继承
					原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。
					而复制得到的副本还可以得到进一步改造。

					Object.create(a, b) // a 是原型， b 是当前对象的值 (ie9以上可用)
						注意 包含引用类型值的属性始终都会共享相应的值

				寄生式继承
					寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。
					为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。

					function createAnother(original){
						var clone = Object(original); //通过调用函数创建一个新对象
						clone.sayHi = function(){ //以某种方式来增强这个对象
							alert("hi");
						};
						return clone; //返回这个对象
					}
					var person = {
						name: "Nicholas",
						friends: ["Shelby", "Court", "Van"]
					};
					var anotherPerson = createAnother(person);
					anotherPerson.sayHi(); //"hi"
					统一给对象增加一样的 属性和方法

				寄生组合式继承
					寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。
					
					function inheritPrototype(subType, superType){
						var prototype = Object(superType.prototype); //创建对象
						prototype.constructor = subType; //增强对象
						subType.prototype = prototype; //指定对象
					}
					function SuperType(name){
						this.name = name;
						this.colors = ["red", "blue", "green"];
					}
					SuperType.prototype.sayName = function(){
						alert(this.name);
					};
					function SubType(name, age){
						SuperType.call(this, name);
						this.age = age;
					}
					inheritPrototype(SubType, SuperType);
					SubType.prototype.sayAge = function(){
						alert(this.age);
					};
					这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的、多余的属性。

				小结
					原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。
	
	函数表达式
		var f = function () {}
		(function () {})
		递归
		闭包 (有必要重看 7.2)
			了解
				1.执行环境
					在每个函数调用的时候会创建一个 执行环境
				2.作用域链
					在创建 执行环境 后，会有对应的作用域，通过函数的 [[Scopes]] 指向 全局环境对象(this) 和 包含函数参数的 活动对象(arguments)
					从函数里层向外扩展 0、1、2、3、4...
					在 全局环境 中调用函数(指的是普通的函数)，函数位于 1 的位置
				3.销毁
					一般来讲，当函数执行完毕后，执行环境 和 局部活动对象 就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。
			
			当执行的函数，返回一个匿名函数时
				function child () {
					return function () {
						...
					}
				}
				var a = child();
				a();
				a = null;
				会按上面的步骤走完，但在第三步时，执行完后 局部活动对象，因为返回 匿名函数 且被 a 引用，所以不会被销毁。 
				当调用 a 函数时，在上面第二步的 作用域链 是这样的，闭包的活动对象、child 的活动对象、全局环境对象
				设置为等于 null 解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域（除了全局作用域）也都可以安全地销毁了。

			由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。
			过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。
			虽然像 V8 等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但请大家还是要慎重使用闭包。

			关于this对象

			内存泄漏
				由于IE9 之前的版本对JScript 对象和COM 对象使用不同的垃圾收集例程，因此闭包在IE 的这些版本中会导致一些特殊的问题。
					function assignHandler(){
						var element = document.getElementById("someElement");
						element.onclick = function(){
							alert(element.id);
						};
					}
					因为函数中存在匿名函数，会导致匿名函数的活动对象不会被销毁，每次使用事件都会触发对 element 的引用

					function assignHandler(){
						var element = document.getElementById("someElement");
						var id = element.id;
						element.onclick = function(){
							alert(id);
						};
						element = null;
					}
					这样修改后
						1.赋值给变量后减少了对 element 的引用
						2.然后 element 不使用后，赋值为 null
						3.这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。

			只要函数中存在匿名函数，并被使用着，这就是闭包。

		模仿块级作用域
			对于 var 来说
				JavaScript 没有块级作用域的概念
				这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。(就是 var 的提升作用域问题)
					function outputNumbers(count){
						for (var i=0; i < count; i++){
							alert(i);
						}
						var i; //重新声明变量
						alert(i); //计数
					}
					等于
					function outputNumbers(count){
						var i;
						for (i=0; i < count; i++){
							alert(i);
						}
						var i; //重新声明变量 (会被无视)
						// var i = 10; 这种会被执行
						alert(i); //计数
					}
				JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。

			模拟块级作用域 (私有作用域) (解决多人开发明命冲突问题)
				(function () {})()
				把函数声明 转 函数表达式，只需在函数前后加对括号，之后只要在后面加对括号就马上执行了

				这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。

		私有变量
			就是函数中可访问，外部不能访问。
			但可以通过定义 特权方法，就是让内部参数能被外部访问。
				function Person(name){
					this.getName = function(){return name;};
					this.setName = function (value) {name = value;};
				}
				var person = new Person("Nicholas");
				alert(person.getName()); //"Nicholas"
				person.setName("Greg");
				alert(person.getName()); //"Greg"

				这样私有变量只能通过特权方法来进行操作。

			静态私有变量
			模块模式
			增强的模块模式
	
	BOM (即 window 对象)
		BOM（浏览器对象模型）
		BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。
		就是浏览器
		
		window 对象
			BOM 的核心对象是 window，它表示浏览器的一个实例。

			全局作用域
				凡是在全局作用域中声明的 变量、函数 都会变成 window 对象的属性和方法。
				全局定义的变量和函数 即 window 上的属性和方法，不能通过 delete 删除，但是直接通过 window['key'] = '' 来定义的可以删除。
					不能删除是因为 描述符configurable 被设置为 false 了。
			
			窗口关系及框架 （基本不用了）
				top 		对象始终指向最外围的框架，也就是整个浏览器窗口
				parent 		对象表示包含当前框架的框架
				<frameset rows="160,*">
					<frame src="frame.htm" name="topFrame">
					<frameset cols="50%,50%">
						<frame src="anotherframe.htm" name="leftFrame">
						<frame src="yetanotherframe.htm" name="rightFrame">
					</frameset>
				</frameset>
				top.frames // 貌似被废弃了

			窗口位置
				确定浏览器的位置
					Firefox 不支持下面这两个
					window.screenLeft		浏览器窗口距离左边距离
					window.screenTop		浏览器窗口距离顶部距离

					Safari、Chrome、Firefox 支持一下 api
					window.screenX
					window.screenY

					兼容写法
					var leftPos = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;
					var topPos = (typeof window.screenTop == "number") ? window.screenTop : window.screenY;
			
			移动窗口
				window.moveTo(x, y)		直接指定位置
				window.moveBy(x, y)		相对位置移动

				这两个方法可能会被浏览器禁用，而且只能对最外层的 window 对象使用。

			窗口大小
				innerWidth和innerHeight 显示的是视口的宽高，outerWidth和outerHeight 显示的是浏览器窗口的宽高 (老版本的chrome，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值)

				window.innerWidth
				window.innerHeight
				window.outerWidth
				window.outerHeight

				ie8之前的版本不支持这些属性，不过，它通过DOM 提供了页面可见区域的相关信息。
				document.documentElement.clientWidth || document.body.clientWidth 		可见宽度
				document.documentElement.clientHeight || document.body.clientHeight		可见高度

				虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小
				兼容例子
					var pageWidth = window.innerWidth,
						pageHeight = window.innerHeight;
					if (typeof pageWidth != "number"){
						if (document.compatMode == "CSS1Compat"){
							pageWidth = document.documentElement.clientWidth;
							pageHeight = document.documentElement.clientHeight;
						} else {
							pageWidth = document.body.clientWidth;
							pageHeight = document.body.clientHeight;
						}
					}

				window.resizeTo(x, y)	设置窗口大小（指定）
				window.resizeBy(x, y)	设置窗口大小（相对）
				这两个方法可能会被浏览器禁用，而且只能对最外层的 window 对象使用。

			导航和打开窗口
				window.open(a, b, c, d)			打开一个窗口
					a：要打开的url
					b：	_self、_parent、_top 		 这三个都是当前页打开
						_blank						会打开新的窗口
						还可以是框架（iframe）的名	  指定 iframe 打开这链接，必须同域名(安全策略的问题)

					c：传递的第二个参数并不是一个已经存在的窗口或框架，可以设置一些属性来定义新开的窗口
							fullscreen 	yes或no 	表示浏览器窗口是否最大化。仅限IE
							height 		数值		表示新窗口的高度。不能小于100
							left 		数值 		表示新窗口的左坐标。不能是负值
							location 	yes或no 	表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器）
							menubar 	yes或no 	表示是否在浏览器窗口中显示菜单栏。默认值为no
							resizable 	yes或no 	表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no
							scrollbars 	yes或no 	表示如果内容在视口中显示不下，是否允许滚动。默认值为no
							status 		yes或no 	表示是否在浏览器窗口中显示状态栏。默认值为no
							toolbar 	yes或no 	表示是否在浏览器窗口中显示工具栏。默认值为no
							top 		数值 		表示新窗口的上坐标。不能是负值
							width 		数值 		表示新窗口的宽度。不能小于100
						var w = window.open("http://www.wrox.com/", "_blank", "height=400,width=400,top=10,left=10,resizable=no,scrollbars=no,status=no,toolbar=no,location=no,menubar=no");
						这里面的属性有可能会被浏览器禁用
					
					调用后会返回当前窗口的对象，可以用来对这窗口进行一些操作
					w.opener	指向创建这窗口的 window
					w.close()	关闭这个创建的窗口
					还可以使用上面的 移动窗口、窗口大小 来对它进行操作
					必须同域名(安全策略的问题)

				弹出窗口屏蔽程序
					被屏蔽后调用 window.open() 会返回 null，但有些浏览器会报错
					try {
						var wroxWin = window.open("http://www.wrox.com", "_blank");
						if (wroxWin == null){
							blocked = true;
						}
					} catch (ex){
						blocked = true;
					}
					if (blocked){
						alert("The popup was blocked!");
					}

			间歇调用和超时调用
				JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码
				为了控制要执行的代码，就有一个JavaScript 任务队列，这些任务会按照将它们添加到队列的顺序执行。
				定时器 到了后会把任务扔到队列中，如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。
				定时器都有一个返回值，用来对它进行取消作用的

				var t = window.setTimeout(function () {}, 1000) 	1秒后执行
				window.clearTimeout(t)		在时间结束前，就能 取消超时调用

				var t = window.setInterval(function () {}, 1000)		每隔1秒，会执行这函数
				window.clearInterval(t)		把这持续执行的定时器取消

				定时器 里的函数都是在 全局作用域 中执行的，因此 this 指向 window (严格模式 下是 undefined)

				建议用 超时定时器 来模拟 间歇定时器
				原因是后一个 间歇 调用可能会在前一个 间歇 调用结束之前启动。而像示例中那样使用超时调用，则完全可以避免这一点。
				var num = 0;
				var max = 10;
				function incrementNumber() {
					num++;
					//如果执行次数未达到max 设定的值，则设置另一次超时调用
					if (num < max) {
						setTimeout(incrementNumber, 500);
					} else {
						alert("Done");
					}
				}
				setTimeout(incrementNumber, 500);
			系统对话框
				这几个弹窗外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。
				显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。

				window.alert()			提示框
				window.confirm()		警视框，需要确认进行下一步
					if (confirm("Are you sure?")) {
						alert("I'm so glad you're sure! ");
					} else {
						alert("I'm sorry to hear you're not sure. ");
					}
				window.prompt()			一个带文本域的弹窗
					var result = prompt("What is your name? ", "");
					if (result !== null) {
						alert("Welcome, " + result);
					}
				chrome 引入了一种新特性，如果当前脚本在执行过程中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框中都会显示一个复选框，以便用户阻止后续的对话框显示，除非用户刷新页面 (貌似只在移动端出现)

				window.print()		显示“打印”对话框
				window.find()		显示“查找”对话框
				这两个对话框是异步显示的
		
		location 对象
			location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是 document 对象的属性
			window.location === document.location
			也可以直接 location 对象来使用
				hash 		"#contents" 			返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串
				host 		"www.wrox.com:80" 		返回服务器名称和端口号（如果有）
				hostname 	"www.wrox.com" 			返回不带端口号的服务器名称
				href 		"http:/www.wrox.com" 	返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值
				pathname 	"/WileyCDA/" 			返回URL中的目录和（或）文件名
				port 		"8080" 					返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串
				protocol 	"http:" 				返回页面使用的协议。通常是http:或https:
				search 		"?q=javascript" 		返回URL的查询字符串。这个字符串以问号开头

			查询字符串参数
				尽管location.search 返回从问号到URL 末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。
				为此，可以像下面这样创建一个函数，用以解析查询字符串，然后返回包含所有参数的一个对象
				function getQueryStringArgs () {
					//取得查询字符串并去掉开头的问号
					const str = location.search;
					const qs = str.length > 0 ? str.substr(1) : '';

					//没有值就可以直接跳出了，但是为了不报错，就返回个空对象
					if (!qs.length) {
						return {};
					}

					//保存数据的对象
					const args = {};

					//取得每一项
					const items = qs.split('&');

					//逐个将每一项添加到 args 对象中
					for (let i in items) {
						const item = items[i].split('=');
						const name = item[0];
						(name && name.length) && (args[name] = item[1]);
					}

					return args;
				}

			位置操作
				location.replace('url')		改变浏览器的链接，不会在浏览器历史记录生成记录

				location.reload()			重新加载当前页面，可以传入 true
					例子
					location.reload(); //重新加载（有可能从缓存中加载）
					location.reload(true); //重新加载（从服务器重新加载）

				以下的操作，浏览器的历史记录中就会生成一条新记录

				location.assign('url')		改变浏览器的链接
					将 location.href 或 window.location 设置为一个URL 值，也会以该值调用 assign() 方法

				以下的属性可以进行修改
				location.hash
				location.search
				location.hostname
				location.pathname
				location.port

				例子
					//假设初始URL 为http://www.wrox.com/WileyCDA/

					//将URL 修改为"http://www.wrox.com/WileyCDA/#section1"
					location.hash = "#section1";

					//将URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"
					location.search = "?q=javascript";

					//将URL 修改为"http://www.yahoo.com/WileyCDA/"
					location.hostname = "www.yahoo.com";

					//将URL 修改为"http://www.yahoo.com/mydir/"
					location.pathname = "mydir";

					//将URL 修改为"http://www.yahoo.com:8080/WileyCDA/"
					location.port = 8080;

					每次修改location 的属性（hash 除外），页面都会以新URL 重新加载。

					在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome 中，修改hash 的值会在浏览器的历史记录中生成一条新记录。
					在IE 的早期版本中，hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash 的URL 时才会被更新。

		navigator 对象 (浏览器信息)
			navigator.userAgent				浏览器的用户代理字符串，存在于所有浏览器中。
			navigator.vendor				浏览器的品牌
			navigator.appVersion			浏览器的版本。一般不与实际的浏览器版本对应
			navigator.plugins				浏览器中安装的插件信息的数组
			navigator.plugins.refresh()		刷新浏览器的插件列表，传 true 页面会刷新

			检测插件
			注册处理程序

		screen 对象
			screen 对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。

		history 对象
			history.go()		传负数后退，正数前进
				history.go(-1)	//后退一页
				history.go(1)	//前进一页
				history.go(2)	//前进两页

			history.back();		后退一页

			history.forward()	前进一页

			history.length		保存着历史记录的数量
				if (history.length == 1){
					//这应该是用户打开窗口后的第一个页面
				}

	客户端检测 (js 浏览器兼容)
		能力检测	 (根据功能来进行判断)
		怪癖检测	 (检测浏览器的bug，来做特殊处理)
		用户代理检测 (navigator.userAgent 根据这个来进行判断)

		检测浏览器的能力使用 typeof 来进行判断

		js 开发中应该对浏览器的能力进行检测来确定下一步的方案，不应该判断用户使用的浏览器

		判断浏览器
			(可以参考“JavaScript高级程序设计(第三版)” 9.3.3 ) 貌似需要做些改动

		在决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。怪癖检测是确定应该如何处理代码的第二选择。
		而用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具有很强的依赖性。

	DOM
		document
		var xxx = docuemnt.body

		在操作节点的函数中，大部分适用于Document、DocumentFragment 和Element。
			例子：
				// xxx.childNodes[0] 是一个元素
				element = xxx.childNodes[0];
				element.getElementById('xx');
				document.getElementById("myDiv").querySelectorAll("em");

		DOM（文档对象模型）描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。

		IE 中的所有DOM 对象都是以COM 对象的形式实现的。这意味着IE 中的DOM 对象与原生JavaScript 对象的行为或活动特点并不一致。(ie 要注意兼容)

		document.hasChildNodes()	貌似有问题
		xxx.ownerDocument			每个节点都有这属性，指向 document。这意味着 任何节点都不能同时存在于两个或更多个文档中，

		节点层次

			Node类型
				JavaScript 中的所有节点类型都继承自Node 类型，因此所有节点类型都共享着相同的基本属性和方法。(ie 除外)
				Node 也自带着一些属性（可以参考“JavaScript高级程序设计(第三版)” 10.1.1 ）

				每个节点都有一个nodeType 属性，用于表明节点的类型。
				xxx.nodeType === Node.ELEMENT_NODE 		表示 xxx 为元素
				xxx.nodeType === 1 						为了确保跨浏览器兼容，最好还是将nodeType 属性与数字值进行比较 （适用于所有浏览器）

				xxx.nodeName		返回元素的标签名(大写)。最好在确定 （nodeType === 1） 时，进行获取。
				xxx.nodeValue		返回 null （始终如此）

				父子，同胞间的操作
					xxx.childNodes		返回所有子节点。一个类数组的 NodeList，可以像数组一样取值，也可以通过NodeList 的 item 方法获取
						xxx.childNodes[1]			找不到返回 undefined
						xxx.childNodes.item(1)		找不到返回 null
					
					xxx.parentNode			返回父节点
					xxx.previousSibling		返回同胞节点，上一个。找不到返回 null
					xxx.nextSibling			返回同胞节点，下一个。找不到返回 null
					xxx.firstChild			返回子节点(NodeList)中的第一个。找不到返回 null
					xxx.lastChild			返回子节点(NodeList)中的最后一个。找不到返回 null

				添加、插入、替换、删除。以下节点操作，只要不是新创建的元素，都是剪切操作。这几个方法必须先取得父节点（使用parentNode 属性）
					xxx.appendChild(a)			在NodeList 末尾添加一个元素
					xxx.insertBefore(a, b)		在NodeList 中添加一个元素。a 要插入的节点，b 要插入位置的节点，当b 传null 时，效果同上（要注意 文本节点 ，这也是个位置）
						xxx.insertBefore(document.createElement('a'), document.body.lastChild)
					xxx.replaceChild(a, b)		a插入的节点,b替换的节点，并返回被替换的节点(就是b)
					xxx.removeChild(a)			a要移除的节点，并返回被删除的节点(就是a)

				xxx.cloneNode()				复制这个节点
											默认浅复制：只会复制这个节点本身，不包含子节点
											传true 深复制：包含这个节点本身和子节点

				xxx.normalize()				合并相连的两个文本（text）节点（某些情况下会导致IE6 崩溃）
				xxx.childNodes[0].splitText()
					xxx.childNodes[0] 必须为文本（text）节点，传入切割坐标。


			Document类型
				JavaScript 通过Document 类型表示文档。
				在浏览器中，document 对象是HTMLDocument（继承自Document 类型）的一个实例，表示整个HTML 页面。
				而且，document 对象是window 对象的一个属性，因此可以将其作为全局对象来访问。

				document.documentElement			始终指向HTML 页面中的<html>元素
				document.body						返回html 元素里的body 元素
				document.head						
				document.title						获取设置文档标题
					document.title = "New page title";

				document.childNodes					返回文档元素列表
				document.doctype					取得对<!DOCTYPE>的引用
					由于浏览器对document.doctype 的支持不一致，因此这个属性的用处很有限。

				document.URL						返回上个当前页面的url
				document.domain						返回上个当前页面的域名（可以通过修改这个来，实现主页面和iframe 通信）
				document.referrer					返回上个页面的url

				document.getElementById()			传入id 获取到元素。如果有相同id 的返回第一个，没有返回null 。
				document.getElementsByTagName()		传入标签名 获取一组元素。是一个HTMLCollection 对象与NodeList 非常类似
					document.getElementsByTagName('*')	// 获取文档中的所有元素，ie 中会返回注释节点
					HTMLCollection 除了有着和NodeList 一样的功能外，还多一个 namedItem 可以根据元素上的name 来从数组中获取
					// <img src="myimage.gif" name="myImage">
					var images = document.getElementsByTagName("img");
					var myImage = images.namedItem("myImage");
					var myImage = images["myImage"];
				document.getElementsByName()		传入name 值获取一组元素。

				document.anchors			包含文档中所有带name 特性的<a>元素
				document.forms				包含文档中所有的<form>元素
				document.images				包含文档中所有的<img>元素
				document.links				包含文档中所有带href 特性的<a>元素
				document.applets			包含文档中所有的<applet>元素

				DOM 一致性检测
					由于DOM 分为多个级别，也包含多个部分，因此检测浏览器实现了DOM 的哪些部分就十分必要了。
					document.implementation 属性就是为此提供相应信息和功能的对象
					DOM1 级:
						document.implementation.hasFeature()		(貌似被弃用了)两个参数：要检测的DOM 功能的名称及版本号。这方法有缺点，最好使用这方法时再进行 能力检测。

				文档写入
					document.write()
					document.writeln()
					document.open()
					document.close()
			
			Element类型
				文档中使用的标签就是 Element(元素)，其中节点包括了元素。
				节点包括：Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。
				查找标签时最好这样写：element.nodeName.toLowerCase() === 'div'

				HTML 元素
					// <div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"></div>
					xxx.id					元素在文档中的唯一标识符
					xxx.className			与元素的class 特性对应，即为元素指定的CSS类
					xxx.title				有关元素的附加说明信息，一般通过工具提示条显示出来
					xxx.lang				元素内容的语言代码，很少使用
					xxx.dir					语言的方向，值为"ltr"（left-to-right，从左至右）或"rtl"（right-to-left，从右至左），也很少使用

				操作特性 (就是标签上的属性)
					注意，根据HTML5 规范，自定义特性应该加上data-前缀以便验证。
					xxx.getAttribute(a)			a 属性名，传入要获取的属性名，获取对应的值，不存在返回null。（属性名不区分大小写）// div.getAttribute("id")
					xxx.setAttribute(a, b)		a 属性名，b 新的值，传入两个参数根据属性名来替换原来的值。（传入的属性名都转为小写）
					xxx.removeAttribute(a)		a 属性名，传入要对应的属性名，彻底删除元素的特性（不仅会清除特性的值，而且也会从元素中完全删除特性）。IE6 及以前版本不支持

					特殊的特性
						xxx.style				会返回一个对象
						xxx.onclick 这类的事件处理程序
						这两个在 ie7 及以前的版本使用 getAttribute 会有问题，返回的值与直接 点属性 出来的值一样。
						这两个（还有class）在 ie7 及以前的版本使用 setAttribute 会有问题，起不到作用。

				attributes 属性
					attributes 属性中包含一个NamedNodeMap，与NodeList 类似，也是一个“动态”的集合。
					元素的每一个特性都由一个Attr 节点表示，每个节点都保存在NamedNodeMap 对象中。

					xxx.attributes
					attributes 属性中包含一系列节点，每个节点的nodeName 就是特性的名称，而节点的nodeValue就是特性的值。
					里面可能会有多余的数据，可以根据每项的 specified 属性为 true 来判断。true，则意味着要么是在HTML 中指定了相应特性，要么是通过setAttribute()方法设置了该特性。(兼容ie7及以前的版本)

					xxx.attributes.getNamedItem(name)			返回nodeName 属性等于name 的节点；
					xxx.attributes.removeNamedItem(name)		从列表中移除nodeName 属性等于name 的节点；
					xxx.attributes.setNamedItem(node)			向列表中添加节点，以节点的nodeName 属性为索引；
					xxx.attributes.item(pos)					返回位于数字pos 位置处的节点。
					例子：xxx.attributes.getNamedItem('id').nodeValue

				创建元素
					document.createElement(a)				a 标签名（HTML 文档中不区分大小写），传入标签名生成并返回一个新元素。

				元素的子节点
					循环 childNodes 所有节点，判断 nodeType === 1 来进行过滤无效节点。
					var ul = document.getElementById("myList");
					var items = ul.getElementsByTagName("li");

			Text类型 	(可以参考“JavaScript高级程序设计(第三版)” 10.1.4 )
				文本节点由Text 类型表示，包含的是可以照字面解释的纯文本内容。
				nodeType 的值为3
				nodeValue 可以获取或设置值

				创建文本节点
					document.createTextNode(a)			a 一串字符串，传入字符串返回text 节点
			
			Comment类型		(可以参考“JavaScript高级程序设计(第三版)” 10.1.5 )
				注释在DOM中是通过Comment 类型来表示的

				nodeType 的值为8；
				nodeValue 的值是注释的内容；

				document.createComment(a)			a 一串字符串，传入字符串返回注释（Comment） 节点

			CDATASection类型		(可以参考“JavaScript高级程序设计(第三版)” 10.1.6 )
				CDATASection 类型只针对基于XML 的文档，表示的是CDATA 区域。
				
			DocumentType类型		(可以参考“JavaScript高级程序设计(第三版)” 10.1.7 )

			DocumentFragment类型		(可以参考“JavaScript高级程序设计(第三版)” 10.1.8 )
				为了避免浏览器反复渲染，可以使用文档片段把要插入的所有内容先放进来，再添加到文档上去。
				document.createDocumentFragment()		创建文档片段

				// <ul id="myList"></ul>
				var fragment = document.createDocumentFragment();
				var ul = document.getElementById("myList");
				var li = null;
				for (var i=0; i < 3; i++){
					li = document.createElement("li");
					li.appendChild(document.createTextNode("Item " + (i+1)));
					fragment.appendChild(li);
				}
				ul.appendChild(fragment);

			Attr类型		(可以参考“JavaScript高级程序设计(第三版)” 10.1.9 )
				元素的特性在DOM 中以Attr 类型来表示。
				特性就是存在于元素的attributes 属性中的节点。

				Attr 对象有3 个属性：name(nodeName)、value(nodeValue) 和specified。
				nodeType 的值为2；
				nodeName 的值是特性的名称；
				nodeValue 的值是特性的值；

				document.createAttribute()			传入特性的名称创建新的特性节点

				xxx.setAttributeNode(a)		a特性节点，把 Attr类型 的特性节点添加到元素上
				xxx.getAttributeNode(a)		a特性节点的nodeName，获取元素上 Attr类型 的特性节点

		DOM 操作技术
			动态脚本
				script.src
				script.type
				script.text
				兼容ie：
					在script标签内添加文本
					try {
						script.appendChild(document.createTextNode("code"));
					} catch (ex){
						script.text = "code";
					}

				// <script type="text/javascript" src="client.js"></script>
				var script = document.createElement("script");
				script.type = "text/javascript";
				script.src = "client.js";
				document.body.appendChild(script);

			动态样式
				link.type
				link.href
				link.rel

				// <link rel="stylesheet" type="text/css" href="styles.css">
				var link = document.createElement("link");
				link.rel = "stylesheet";
				link.type = "text/css";
				link.href = "style.css";
				var head = document.getElementsByTagName("head")[0] || document.head;
				head.appendChild(link);

				style.type
				兼容ie：
					在style标签内添加文本
					try{
						style.appendChild(document.createTextNode("body{background-color:red}"));
					} catch (ex){
						style.styleSheet.cssText = "body{background-color:red}";
					}

				var style = document.createElement("style");
				style.type = "text/css";
				style.appendChild(document.createTextNode("body{background-color:red}"));
				var head = document.getElementsByTagName("head")[0];
				head.appendChild(style);

			操作表格		(可以参考“JavaScript高级程序设计(第三版)” 10.2.3 )
				有很简便的写法

		使用NodeList
			理解NodeList 及其“近亲”NamedNodeMap 和HTMLCollection，是从整体上透彻理解DOM的关键所在。
			这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。
			注意：因为是动态的，循环时要注意。

	DOM 扩展
		var xxx = docuemnt.body

		选择符API
			ie8+ 以上才支持
			Selectors API 根据CSS 选择符选择与某个模式匹配的DOM 元素。
			document.querySelector(a)				a 一个CSS 选择符，返回与该模式匹配的第一个元素，没有返回 null
			document.querySelectorAll(a)			a 一个CSS 选择符，返回与该模式匹配的一个 NodeList 的实例，没有找到 NodeList 就是空的
			document.matchesSelector(a)				a 一个CSS 选择符，调用元素与该选择符匹配，返回true；否则，返回false。（貌似浏览器还不支持）

		元素遍历
			IE9+ 以上才支持
			以下这些属性会忽略文本节点
			xxx.childElementCount			返回子元素（不包括文本节点和注释）的个数。
			xxx.firstElementChild			指向第一个子元素；firstChild 的元素版。
			xxx.lastElementChild			指向最后一个子元素；lastChild 的元素版。
			xxx.previousElementSibling		指向前一个同辈元素；previousSibling 的元素版。
			xxx.nextElementSibling			指向后一个同辈元素；nextSibling 的元素版。

		HTML5
			与类相关的扩充
				ie10 以上才支持
				document.getElementsByClassName(a)				a 一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。IE9+ 以上才支持
				xxx.classList					返回该元素的一组类名
				xxx.classList.add(a)			将给定的字符串值添加到列表中。如果值已经存在，就不添加了。
				xxx.classList.contains(a)		表示列表中是否存在给定的值，如果存在则返回true，否则返回false。
				xxx.classList.remove(a)			从列表中删除给定的字符串。
				xxx.classList.toggle(a)			如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。这样，前面那么多行代码用下面这一行代码就可以代替了：

			焦点管理
				HTML5 也添加了辅助管理DOM 焦点的功能。
				document.activeElement			这个属性始终会引用DOM 中当前获得了焦点的元素。
				document.hasFocus()				用来判断是否处于交互中。true 时用户正在使用input 之类的，

			HTMLDocument的变化
				document.readyState				返回文档的加载状态	loading，正在加载文档；complete，已经加载完文档
					window.onload = function () {
						if (docuemnt.readyState === 'complete') {// 文档加载完成执行}
					}

				document.compatMode				用来确认浏览器的模式  CSS1Compat，标准模式；BackCompat，混杂模式
				document.head					HTML5 新增的 ie9以上可用 (兼容：document.head || document.getElementsByTagName('head')[0])

			字符集属性
				document.charset				表示文档中实际使用的字符集
				document.defaultCharset			表示根据默认浏览器及操作系统的设置

			自定义数据属性 （ie 貌似不支持）
				HTML5 规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。
				// <div id="myDiv" data-appId="12345" data-myname="Nicholas"></div>
				var div = document.getElementById("myDiv");
				var appId = div.dataset.appId;
				div.dataset.appId = 23456;

				通过 dataset 的属性可以取值与赋值

			插入标记
				这几个操作要注意性能方面的问题（指的不要频繁调用），还有占用内存的问题（指的是原html上绑定的事件要先清除掉）。
				xxx.innerHTML		获取元素下的所有子节点，赋值就替换元素下的所有子节点
					注意：不要指望所有浏览器返回的innerHTML 值完全相同（ie8及以下貌似返回的节点都是大写的）
						 不要用来插入 script 标签。
						 插入 style 标签，ie8及以下的版本 时插入这标签时要前置一个“有作用域的元素(就是下面style标签前面的_)” 
						 	如：div.innerHTML = "_<style type=\"text/css\">body {background-color: red; }</style>";
						 有些标签不支持 innerHTML 属性
					
					window.toStaticHTML()		这个方法接收一个参数，即一个HTML 字符串；返回一个经过无害处理后的版本（ie8 及以上版本可用）
				
				xxx.outerHTML		返回调用它的元素及所有子节点的HTML 标签，赋值就完全替换调用元素
				xxx.childNodes[0].insertAdjacentHTML()
					// xxx.childNodes[0] 是一个元素
					第一个参数必须是下列值之一
						同级
						"beforebegin"，在当前元素之前插入一个紧邻的同辈元素；
						"afterend"，在当前元素之后插入一个紧邻的同辈元素；
						子级
						"afterbegin"，在当前元素之下插入一个新的子元素 或 在第一个子元素之前再插入新的子元素；
						"beforeend"，在当前元素之下插入一个新的子元素 或  在最后一个子元素之后再插入新的子元素；
					第二个参数是一个HTML 字符串（与innerHTML 和outerHTML的值相同）

			scrollIntoView()方法
				可以在所有HTML 元素上调用
				这个方法主要是把内容与视口的 顶部 或 底部 对齐。
				document.body.scrollIntoView(true)	顶部对齐
				document.body.scrollIntoView(false)	底部对齐

		专有扩展
			文档模式 （貌似只对 ie 使用的）
				IE8 引入了一个新的概念叫“文档模式”（document mode）。
				页面的文档模式决定了可以使用什么功能。

				IE5：以混杂模式渲染页面（IE5 的默认模式就是混杂模式）。IE8 及更高版本中的新功能都无法使用。
				IE7：以IE7 标准模式渲染页面。IE8 及更高版本中的新功能都无法使用。
				IE8：以IE8 标准模式渲染页面。IE8 中的新功能都可以使用，因此可以使用Selectors API、更多CSS2 级选择符和某些CSS3 功能，还有一些HTML5 的功能。不过IE9 中的新功能无法使用。
				IE9：以IE9 标准模式渲染页面。IE9 中的新功能都可以使用，比如ECMAScript 5、完整的CSS3以及更多HTML5 功能。这个文档模式是最高级的模式。

				<meta http-equiv="X-UA-Compatible" content="IE=Edge">		强制ie 使用某种模式渲染页面，不同的content 值不同的模式
					Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于IE8，始终保持以IE8 标准模式渲染页面。对于IE9，则以IE9 标准模式渲染页面。
					EmulateIE9：如果有文档类型声明，则以IE9 标准模式渲染页面，否则将文档模式设置为IE5。
					EmulateIE8：如果有文档类型声明，则以IE8 标准模式渲染页面，否则将文档模式设置为IE5。
					EmulateIE7：如果有文档类型声明，则以IE7 标准模式渲染页面，否则将文档模式设置为IE5。
					9：强制以IE9 标准模式渲染页面，忽略文档类型声明。
					8：强制以IE8 标准模式渲染页面，忽略文档类型声明。
					7：强制以IE7 标准模式渲染页面，忽略文档类型声明。
					5：强制将文档模式设置为IE5，忽略文档类型声明。

				document.documentMode 			返回页面的采用的文档模式
			
			xxx.children			返回所有子元素（ie8及更早的版本会包含注释节点）
			xxx.contains(a)			a 某个元素，判断值是否属于该元素的子节点，返回布尔值
			xxx.compareDocumentPosition()			确定节点间的关系 (可以参考“JavaScript高级程序设计(第三版)” 11.4.3 )
			xxx.innerText			获取元素下的所有文本，赋值就替换元素下的所有子节点
				注意：Firefox 低版本不支持该属性，可以用 textContent（ie9 及以上才能使用） 代替。
					 innerText 与textContent（包含样式和脚本代码） 返回的内容并不完全一样
				兼容写法
					function getInnerText (element) { return (typeof element.textContent == "string") ? element.textContent : element.innerText; }
					function setInnerText (element, text) { if (typeof element.textContent == "string"){ element.textContent = text; } else { element.innerText = text; } }
			xxx.outerText			返回调用它的元素及所有子节点的文本，赋值就完全替换调用元素

		滚动
			貌似只适用于 Safari 和Chrome (webkit)
			xxx.scrollIntoViewIfNeeded(a)		a 布尔值，是否居中显示。只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。
			scrollByPages、scrollByLines 这两个貌似用不了

	DOM2 和 DOM3	(这章看的懵，有空要重新看。可以参考“JavaScript高级程序设计(第三版)” 12 )
		DOM1 级主要定义的是HTML 和XML 文档的底层结构。DOM2 和DOM3 级则在这个结构的基础上引入了更多的交互能力，也支持了更高级的XML 特性。

		DOM2 级核心（DOM Level 2 Core）：在1 级核心基础上构建，为节点添加了更多方法和属性。
		DOM2 级视图（DOM Level 2 Views）：为文档定义了基于样式信息的不同视图。
		DOM2 级事件（DOM Level 2 Events）：说明了如何使用事件与DOM文档交互。
		DOM2 级样式（DOM Level 2 Style）：定义了如何以编程方式来访问和改变CSS 样式信息。
		DOM2 级遍历和范围（DOM Level 2 Traversal and Range）：引入了遍历DOM 文档和选择其特定部分的新接口。
	 	DOM2 级 HTML（DOM Level 2 HTML）：在1 级HTML 基础上构建，添加了更多属性、方法和新接口。
		DOM3 级又增加了“XPath”模块和“加载与保存”（Load and Save）模块。
					
		DOM 变化
			DOM2 级和3 级的目的在于扩展DOM API，以满足操作XML 的所有需求，同时提供更好的错误处理及特性检测能力。

			针对XML命名空间的变化		 (可以参考“JavaScript高级程序设计(第三版)” 12.1.1 )
				主要对 xml 和 xhtml 命名空间做解释
				之前的 dom api 后缀加 NS 的都是针对命名空间来的

			其他方面的变化		 (可以参考“JavaScript高级程序设计(第三版)” 12.1.2 )
				// <!DOCTYPE html>
				主要对 documentType 的操作

				document.importNode()				类似于 document.cloneNode()，但是可以从一个文档复制到另一个文档，这个方法在HTML 文档中并不常用，在XML 文档中用得比较多。

				DOM2 级视图
					document.defaultView				获取文档的归属窗口
						ie 不支持这属性， document.parentWindow 这个代替

				DOM2 级核心
					document.implementation 对象规定了两个新方法：createDocumentType()和createDocument()

					document.implementation.createDocumentType("html", "-//W3C//DTD HTML 4.01//EN", "http://www.w3.org/TR/html4/strict.dtd")
						创建一个新的DocumentType节点，接受3 个参数：文档类型名称、publicId、systemId。只在创建新文档时有用

					document.implementation.createDocument("", "root", null);
						创建新文档用到createDocument()方法。这个方法接受3 个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型

					document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html",
						document.implementation.createDocumentType("html", " -//W3C//DTD XHTML 1.0 Strict//EN", "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd")
					);
					这样，就创建了一个带有适当命名空间和文档类型的新XHTML 文档。
				
				DOM2 级HTML
					document.implementation.createHTMLDocument("New Doc");
						这个方法的用途是创建一个完整的HTML 文档，包括<html>、<head>、<title>和<body>元素。这个方法只接受一个参数，即新创建文档的标题（放在<title>元素中的字符串）
						注意：只有Opera 和Safari 支持这个方法。

				DOM3 级引入了两个辅助比较节点的方法
					这两个方法都接受一个节点参数，并在传入节点与引用的节点 相同 或 相等 时返回true。
					相同，指的是两个节点引用的是同一个对象。
					相等，指的是两个节点是相同的类型，具有相等的属性（nodeName、nodeValue，等等），而且它们的attributes 和childNodes 属性也相等（相同位置包含相同的值）
					isSameNode()		判断节点是否相同
					isEqualNode()		判断节点是否相等
					例子
						var div1 = document.createElement("div");
						div1.setAttribute("class", "box");

						var div2 = document.createElement("div");
						div2.setAttribute("class", "box");

						alert(div1.isSameNode(div1)); //true
						alert(div1.isEqualNode(div2)); //true
						alert(div1.isSameNode(div2)); //false

				DOM3 引入的（貌似还没支持）
					document.body.setUserData("name", "Nicholas", function(){});
					document.body.getUserData("name");

				DOM2级中都有了一个新属性
					框架内的调用必须同域名
					contentDocument 		针对frame 使用的，主要是获取frame 的document
						var iframe = document.getElementById("myIframe");
						var iframeDoc = iframe.contentDocument; //在IE8 以前的版本中无效
						iframe.contentWindow 	所有浏览器都支持这个，用来获取frame 的window

		样式
			确定浏览器是否支持DOM2 级定义的CSS 能力 （貌似被弃用）
				var supportsDOM2CSS = document.implementation.hasFeature("CSS", "2.0");
				var supportsDOM2CSS2 = document.implementation.hasFeature("CSS2", "2.0");

			访问元素的样式

				样式里的 短划线 键值，在javascript 里要用驼峰大小写形式来访问
				var xxx = document.body;
				xxx.style.backgroundColor = 'red';
				xxx.style.fontSize = '12px';

				注意：所有度量值都必须指定一个度量单位

				一些style 的属性和方法 (注意：大部分需要ie9+以上才支持)
					(propertyName) 输入的值和样式的键一样都有 短划线，不能用驼峰大小写
					xxx.style.cssText					获取 style 属性里的字符串，也可以直接写入
					xxx.style.length					获取 style 属性设置的键值长度
					xxx.style.parentRule				表示CSS 信息的CSSRule 对象。
					xxx.style.item(index)				返回给定位置的CSS 属性的名称。
					xxx.style.getPropertyCSSValue()		(貌似没这函数) 返回包含给定属性值的CSSValue 对象。
					xxx.style.getPropertyPriority(propertyName)			如果给定的属性使用了!important 设置，则返回"important"；否则，返回空字符串。
					xxx.style.getPropertyValue(propertyName)			返回给定属性的字符串值。
					xxx.style.removeProperty(propertyName)				从样式中删除给定属性。
					xxx.style.setProperty(propertyName, value, priority)
						xxx.style.setProperty('background-color', '#000' , 'important' || '')

				计算的样式		(可以参考“JavaScript高级程序设���(第三版)” 12.2.1 )
					(不太明白)
					document.defaultView.getComputedStyle()
						这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（例如":after"）。如果不需要伪元素信息，第二个参数可以是null。

					document.body.currentStyle;
						ie 可以通过这个取到

					最重要的一条是要记住所有计算的样式都是只读的；不能修改计算后样式对象中的CSS 属性。

			操作样式表
				CSSStyleSheet对象 就是 link、style 标签的内容展示，可以通过它来操作样式。

				document.styleSheets			返回样式表(CSSStyleSheet对象)列表。文档加载的样式表，包括通过<link>元素包含的样式表和在<style>元素中定义的样式表。
					每项都有以下属性(除了disabled 属性之外，其他属性都是只读的。)
					disabled：			表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为true 可以禁用样式表。
					href：				如果样式表是通过<link>包含的，则是样式表的URL；否则，是null。
					parentStyleSheet：	在当前样式表是通过@import 导入的情况下，这个属性是一个指向导入它的样式表的指针。
					title：				ownerNode 中title 属性的值。
					type：				表示样式表类型的字符串。对CSS 样式表而言，这个字符串是"type/css"。
					media：
						当前样式表支持的所有媒体类型的集合。
						与所有DOM 集合一样，这个集合也有一个length 属性和一个item()方法。
						也可以使用方括号语法取得集合中特定的项。
						如果集合是空列表，表示样式表适用于所有媒体。
						在IE 中，media 是一个反映<link>和<style>元素media特性值的字符串。
					ownerNode （就是当前包含样式的标签 link、style 这些）
						指向拥有当前样式表的节点的指针，样式表可能是在HTML 中通过<link>或<style/>引入的（在XML 中可能是通过处理指令引入的）。
						如果当前样式表是其他样式表通过@import 导入的，则这个属性值为null。
						IE 不支持这个属性。

					在支持以上所有这些属性的基础上，CSSStyleSheet 类型还支持下列属性和方法：
						cssRules：					样式表中的样式规则集合。IE 不支持这个属性，但有一个类似的rules 属性。
							每项的属性
							cssText				返回整条规则对应的文本。IE 不支持这个属性。
							selectorText		返回当前规则的选择符文本。
							style				一个CSSStyleDeclaration 对象，可以通过它设置和取得规则中特定的样式值。
								这个style 	可以按“访问元素的样式”来
							parentRule			如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为null。IE 不支持这个属性。
							parentStyleSheet	当前规则所属的样式表。IE 不支持这个属性。
							type				表示规则类型的常量值。对于样式规则，这个值是1。IE 不支持这个属性。

						insertRule(rule,index)：	（注意兼容）就是添加新规则。向cssRules 集合中指定的位置插入rule 字符串。IE 不支持这个方法，但支持一个类似的addRule()方法。
						deleteRule(index)：			删除cssRules 集合中指定位置的规则。IE 不支持这个方法，但支持一个类似的removeRule()方法。
						ownerRule：					如果样式表是通过@import 导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为null。IE 不支持这个属性。
				
				通过标签取得样式表 (CSSStyleSheet对象)
					sheet ie不支持这属性，用styleSheet 代替
					function getStyleSheet(element){ return element.sheet || element.styleSheet; }
					//取得第一个<link/>元素引入的样式表
					var link = document.getElementsByTagName("link")[0];
					var sheet = getStylesheet(link);

					var rules = sheet.cssRules || sheet.rules;			//取得规则列表，就是自己定义的样式规则

			元素大小
				var mydiv = document.getElementById('myDiv');
				1. 偏移量 		（偏移量属性都是只读的，而且每次访问它们都需要重新计算。）
					元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意，不包括外边距）。
					内容 + 内边距 + 边框
					mydiv.offsetHeight		元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框高度和下边框高度。
					mydiv.offsetWidth		元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。
					mydiv.offsetLeft		元素的左外边框至包含元素的左内边框之间的像素距离。
					mydiv.offsetTop			元素的上外边框至包含元素的上内边框之间的像素距离。

					mydiv.offsetParent		获取父级元素（注意<td>元素的offsetParent 是作为其祖先元素的<table>元素）
					例子：
						offsetTop 也可以用这函数(修改下)
						function getElementLeft(element){
							var actualLeft = element.offsetLeft;
							var current = element.offsetParent;
							while (current !== null){
								actualLeft += current.offsetLeft;
								current = current.offsetParent;
							}
							return actualLeft;
						}

				2. 客户区大小			（客户区大小也是只读的，也是每次访问都要重新计算的。）
					元素的客户区大小（client dimension），指的是元素内容及其内边距所占据的空间大小
					内容 + 内边距

					浏览器视口大小，使用document.documentElement 或document.body
						document.body.clientWidth
						document.body.clientHeight
						document.documentElement.clientWidth
						document.documentElement.clientHeight

				3. 滚动大小
					mydiv.scrollHeight：	在没有滚动条的情况下，元素内容的 总 高度。（文档的整个高度）
					mydiv.scrollWidth：		在没有滚动条的情况下，元素内容的 总 宽度。（文档的整个宽度）
					mydiv.scrollLeft：		被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。
				 	mydiv.scrollTop：		被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。

					跨浏览器
						确定文档的总高度、总宽度
							scrollHeight、scrollWidth、clientHeight、clientWidth 		这两组在不同的浏览器会有不同的变现
							混杂模式下的IE，则需要用document.body 代替document.document-Element。
							var docHeight = Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight);
							var docWidth = Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth);

				4. 确定元素大小
					元素都提供了一个 getBoundingClientRect() 方法。这个方法返回会一个矩形对象，包含4 个属性：left、top、right 和bottom。这些属性给出了元素在页面中相对于视口的位置。
					自测的浏览器（包含6 个属性：left、top、right、bottom、height 和 width）
					id8 及老版本    返回的都是4个属性
						之后的版本  返回的都是6个属性
					document.body.getBoundingClientRect()
		
		遍历 （ie8 及以下不支持）
			NodeIterator
				document.createNodeIterator()		创建一个dom 迭代器，四个参数。
					 root								想要作为搜索起点的树中的节点。
					 whatToShow						表示要访问哪些节点的数字代码。
					 filter							是一个NodeFilter 对象，或者一个表示应该接受还是拒绝某种特定节点的函数。
						过滤器要返回指定的值，来确定改节点是否需要。
						如果应该访问给定的节点，该方法返回 NodeFilter.FILTER_ACCEPT
						如果不应该访问给定的节点，该方法返回 NodeFilter.FILTER_SKIP
					 entityReferenceExpansion			布尔值，表示是否要扩展实体引用。这个参数在HTML 页面中没有用，因为其中的实体引用不能扩展。
				
				改函数返回一个dom 列表迭代器
					nextNode()			获取下一个dom，最终返回null
					previousNode()		获取上一个dom，最终返回null
				
				whatToShow		以下属性都是whatToShow 一个位掩码
					 NodeFilter.SHOW_ALL：显示所有类型的节点。
					 NodeFilter.SHOW_ELEMENT：显示元素节点。
					 NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值。
					 NodeFilter.SHOW_TEXT：显示文本节点。
					 NodeFilter.SHOW_CDATA_SECTION：显示CDATA 节点。对HTML 页面没有用。
					 NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML 页面没有用。
					 NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML 页面没有用。
					 NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML 页面没有用。
					 NodeFilter.SHOW_COMMENT：显示注释节点。
					 NodeFilter.SHOW_DOCUMENT：显示文档节点。
					 NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点。
					 NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML 页面没有用。
					 NodeFilter.SHOW_NOTATION：显示符号节点。对HTML 页面没有用。
				

				例子：
					<div id="div1">
						<p><b>Hello</b> world!</p>
						<ul>
							<li>List item 1</li>
							<li>List item 2</li>
							<li>List item 3</li>
						</ul>
					</div>
					var iterator = document.createNodeIterator(document.getElementById('div1'), NodeFilter.SHOW_ELEMENT, (node) => {
						return node.tagName.toLowerCase() === 'li' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
					}, false);
					var node = iterator.nextNode();
					while (node !== null) {
						console.log(node.tagName); //输出标签名
						node = iterator.nextNode();
					}

			TreeWalker
				TreeWalker 是NodeIterator 的一个更高级的版本。
				document.createTreeWalker()				这个方法与document.createNodeIterator() 方法一样。
				除了包括document.createNodeIterator() 的 nextNode 和 previousNode 功能外，还包括：
				 parentNode()			遍历到当前节点的父节点；
				 firstChild()			遍历到当前节点的第一个子节点；
				 lastChild()			遍历到当前节点的最后一个子节点；
				 nextSibling()			遍历到当前节点的下一个同辈节点；
				 previousSibling()		遍历到当前节点的上一个同辈节点。

				在第三个参数 过滤器，有些不一样 （就是多了个是否要 遍历父节点 中的 子节点）
					NodeFilter.FILTER_ACCEPT
					NodeFilter.FILTER_SKIP		跳过相应节点继续前进到子树中的下一个节点
					NodeFilter.FILTER_REJECT	跳过相应节点及该节点的整个子树

				多了个属性 currentNode 		可以获取当前遍历到的节点，也可以赋值改变遍历起点

		范围 （ie8 及以下不支持）
			获取某个范围里的节点
			document.createRange()

			var range1 = document.createRange();
				range2 = document.createRange();
			var p1 = document.getElementById("p1");
			range1.selectNode(p1);				// 获取该节点的父节点
			range2.selectNodeContents(p1);		// 获取该节点
		
		总结
			“DOM2 级样式”模块主要针对操作元素的样式信息而开发...

	事件
		（一个封装好的对象 EventUtil 用来款浏览器绑定事件，可以参考“JavaScript高级程序设计(第三版)” p372 )
		var btn = document.getElementById("myBtn");
		事件流
			IE8 及更早版本不支持DOM 事件流。

			事件冒泡	事件触发时从里到外 （基本都使用冒泡）
			事件捕获	事件触发时从外到里
		
			DOM事件流
				“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。

		事件处理程序 （就是dom 上响应的函数）
			响应某个事件的函数就叫做 事件处理程序（或 事件侦听器）
			原始的写法
				<input type="button" value="Click Me" onclick="showMessage()" />  	缺点：在js 没加载完成调用会报错

			DOM0 级事件处理程序
				btn.onclick = function () {alert(this.id)}		// 指定事件处理程序
				btn.onclick = null;		// 删除事件处理程序

			DOM2 级事件处理程序 （ie9 及以上的版本支持）
				使用 DOM2级 添加事件处理程序，同一个事件名可以添加多个事件处理程序（按照添加它们的顺序触发）。
				3 个参数：要处理的 事件名、作为事件处理程序的函数、一个布尔值（true，表示在捕获阶段调用事件处理程序；false，表示在冒泡阶段调用事件处理程序）。
				addEventListener()			指定事件（注意匿名函数无法移除）
				removeEventListener()		删除事件（注意匿名函数无法移除）
				// 添加例子
				btn.addEventListener("click", function () { alert(this.id) }, false);
				btn.addEventListener("click", function () { alert('aaa') }, false);
				// 删除例子
				var fun = function () { console.log('bbb') }
				btn.addEventListener("click", fun, false);
				btn.removeEventListener("click", fun, false);

			IE事件处理程序  （ie8 及以下的版本支持）
				基本同上，但只接受前两个参数（事件名前要加 on，事件处理程序中使用 this 指向的是 window），只支持事件冒泡。
				同一个事件名添加多个事件时，和上面的不同，按相反的顺序来执行
				attachEvent()
				detachEvent()

			跨浏览器的事件处理程序
				var EventUtil = {
					addHandler: function (element, type, handler) {
						if (element.addEventListener){
							element.addEventListener(type, handler, false);
						} else if (element.attachEvent){
							element.attachEvent("on" + type, handler);
						} else {
							element["on" + type] = handler;
						}
					},
					removeHandler: function (element, type, handler) {
						if (element.removeEventListener){
							element.removeEventListener(type, handler, false);
						} else if (element.detachEvent){
							element.detachEvent("on" + type, handler);
						} else {
							element["on" + type] = null;
						}
					}
				};
		
		事件对象
			DOM中的事件对象 （可以参考“JavaScript高级程序设计(第三版)” 13.3.1 )
				在触发DOM上的某个事件时，会产生一个事件对象event。所有浏览器都支持event 对象，但支持方式不同。

				event.currentTarget			指向this
				event.target				只包含事件的实际目标（触发的地方）（可能会和this 不等）
					这两个要注意 当一个元素里包含多个子元素，给父元素设置 click 事件，通过 target 可以拿到点击的那个子元素， currentTarget 可以拿到本身。

				event.preventDefault()		阻止特定事件的默认行为
				event.stopPropagation()		立即停止事件在DOM 层次中的传播，即取消进一步的事件捕获或冒泡。

				只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。

			IE中的事件对象  （可以参考“JavaScript高级程序设计(第三版)” 13.3.2 )
				与DOM中的获取方式不同，ie 在触发事件时，通过 window.event 获取事件对象 （DOM0 级时要这样获取）
				window.event.returnValue = false		阻止默认行为
				window.event.cancelBubble = true		停止事件冒泡

			跨浏览器的事件对象		（可以参考“JavaScript高级程序设计(第三版)” 13.3.3 )
		
		事件类型
			UI事件
				UI 事件指的是那些不一定与用户操作有关的事件。
				这些事件都与 window 对象或表单控件相关。
				load			当页面完全加载后在window 上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在<img>元素上面触发，或者当嵌入的内容加载完毕时在<object>元素上面触发。
					IE8 及之前版本不会生成 event 对象。IE9 修复了这个问题。
					// 确定文档加载完成
					window.onload = function (event) {}

					// 貌似用的很少，新图像元素不一定要从添加到文档后才开始下载，只要设置了src 属性就会开始下载。
					imgDom.onload = function (event) {}
					// 常用的加载图片方法
					var m = new Image();m.onload = function (event) {};m.src = 'xxx.jpg';

					// 动态加载js
					// 动态加载css

				unload			当页面完全卸载后在window 上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在<object>元素上面触发。

				resize			当窗口或框架的大小变化时在window 或框架上面触发。
					window.onresize = function (event) {console.log(event)}

				scroll			当用户滚动带滚动条的元素中的内容时，在该元素上面触发。<body>元素中包含所加载页面的滚动条。
					window.scroll = function (event) {console.log(event)}
					一部分浏览器会基于 html 来跟踪滚动位置，一部分浏览器会基于 body 来跟踪滚动位置
					document.documentElement.scrollTop || document.body.scrollTop

				abort			在用户停止下载过程时，如果嵌入的内容没有加载完，则在<object>元素上面触发。
				error			当发生JavaScript 错误时在window 上面触发，当无法加载图像时在<img>元素上面触发，当无法加载嵌入内容时在<object>元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。
				select			当用户选择文本框（<input>或<texterea>）中的一或多个字符时触发。

			焦点事件
				blur			在元素失去焦点时触发。所有浏览器都支持它
				focus			在元素获得焦点时触发。所有浏览器都支持它

				这两个可以ie5.5 就支持
				focusout		在元素失去焦点时触发。
				focusin			在元素获得焦点时触发。

			鼠标与滚轮事件
				mousedown			在用户按下了任意鼠标按钮时触发。
				mouseup				在用户释放鼠标按钮时触发。
				click				在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发（需要得到焦点）。
				dblclick			ie8及之前的版本存在问题，在用户双击主鼠标按钮（一般是左边的按钮）时触发。

				mouseout			在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。（包括内部的子元素）
				mouseover			在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。
					这两个事件对象带有 relatedTarget， ie的用 mouseover 对应 fromElement、mouseout 对应 toElement。（貌似返回目标对象的父元素）
					（兼容代 可以参考“JavaScript高级程序设计(第三版)” p391）

				mousemove			当鼠标指针在元素内部移动时重复地触发。

				只有这两事件不冒泡。上面的都冒泡，也可以被取消
				mouseenter			在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。
				mouseleave			在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。

				mousewheel			这个事件跟踪鼠标滚轮 （这个貌似需要注意兼容）
				DOMMouseScroll		这是 firefox 的鼠标滚轮事件

				鼠标事件对象保存着 clientX 和 clientY (所有浏览器都支持这两个属性)，这样确定鼠标在视口中的位置
					document.getElementById("myDiv").onclick = (event) => {console.log(`${event.clientX}, ${event.clientY}`)}
				
				鼠标事件对象保存着 pageX 和 pageY，确定在文档（特别是带滚动条的文档）中的位置。（IE8 及更早版本不支持事件对象上的页面坐标）
					通过计算得到
					(document.documentElement.scrollTop || document.body.scrollTop) + event.clientY
					(document.documentElement.scrollLeft || document.body.scrollLeft) + event.clientX

				屏幕坐标位置 screenX 和 screenY，相对于整个屏幕的坐标信息

				event 事件对象的鼠标属性
					event.shiftKey、event.ctrlKey、event.altKey 和 event.metaKey，和鼠标事件组合触发。就是点击时候，按住键盘上对应的按钮会返回 true。
						ie8及之前版本不支持 metaKey 属性。

					event.button		鼠标按钮按下的代表值 （可以参考“JavaScript高级程序设计(第三版)” p392）
					event.detail		连续点鼠标的次数

					event.clientX		鼠标在视口的位置
					event.clientY		鼠标在视口的位置
					event.pageX			鼠标在文档的位置
					event.pageY			鼠标在文档的位置
					event.offsetX		光标相对于目标元素边界的坐标
					event.offsetY		光标相对于目标元素边界的坐标

					event.wheelDelta	对应 mousewheel 事件，表示向上或向下滚动 (Opera要注意兼容)
					event.detail		对应 DOMMouseScroll 事件，表示向上或向下滚动 (firefox的兼容)

				注意
					只有在同一个元素上相继触发mousedown 和mouseup 事件，才会触发click 事件；
					如果mousedown 或mouseup 中的一个被取消，就不会触发click 事件。
					类似地，只有触发两次click 事件，才会触发一次dblclick 事件。
					如果有代码阻止了连续两次触发click 事件（可能是直接取消click事件，也可能通过取消mousedown 或mouseup 间接实现），那么就不会触发dblclick 事件了。

			键盘与文本事件
				一般使用在 输入框 这些元素上。
				keydown					当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。
				keypress				当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。
				keyup					当用户释放键盘上的键时触发。
				input					在文本插入文本框之前会触发。
				textInput				只有可编辑区域才能触发（支持textInput 属性的浏览器有IE9+、Safari 和Chrome。只有IE 支持inputMethod 属性。）
										按下能够输入实际字符的键时才会被触发
										event 对象中还包含一个data 属性，值是用户输入的值

				event 事件对象的键盘属性
					keyCode			返回键盘上按键对应的keyCode(keyup 和 keydown 里有效)
						在Firefox 和Opera 中，按分号键时keyCode值为59，也就是ASCII 中分号的编码；但IE 和Safari 返回186，即键盘中按键的键码。

					charCode		这个属性只有在发生 keypress 事件时才包含值，而且这个值是按下的那个键所代表字符的ASCII 编码 （DOM3不支持）

					DOM3 新增 存在兼容问题（可以参考“JavaScript高级程序设计(第三版)” p400）
						（IE9 支持key 属性，但不支持char 属性。）
						key				了取代keyCode 而新增的，它的值是一个字符串
						char			在按下字符键时的行为与key 相同，但在按下非字符键时值为null。
						keyIdentifier	webkit 的支持
						location		这是一个数值，表示按下了什么位置上的键
						keyLocation		webkit 的支持

			复合事件（可以参考“JavaScript高级程序设计(第三版)” 13.4.5）
				复合事件（composition event）是DOM3 级事件中新添加的一类事件，用于处理IME 的输入序列。IME（Input Method Editor，输入法编辑器）可以让用户输入在物理键盘上找不到的字符。
				例如，使用拉丁文键盘的用户通过IME 照样能输入日文字符。IME 通常需要同时按住多个键，但最终只输入一个字符。

			变动事件
				DOM2 级的变动（mutation）事件能在DOM 中的某一部分发生变化时给出提示。变动事件是为XML或HTML DOM设计的，并不特定于某种语言。
				在对 dom 进行操作时执行响应的函数（监听dom变化）。
				事件
					DOMSubtreeModified				在DOM 结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。
					DOMNodeInserted					在一个节点作为子节点被插入到另一个节点中时触发。
					DOMNodeRemoved					在节点从其父节点中被移除时触发。
					DOMNodeInsertedIntoDocument		在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在DOMNodeInserted 之后触发。
					DOMNodeRemovedFromDocument		在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved 之后触发。
					DOMAttrModified					在特性被修改之后触发。
					DOMCharacterDataModified		在文本节点的值发生变化时触发。
				
				例子：
					document.body.addEventListener('DOMNodeRemoved', function (e) {console.log(e)})
			
			HTML5 事件
				contextmenu 事件（可以参考“JavaScript高级程序设计(第三版)” p406）
					自定义上下文自定义菜单
					通常使用contextmenu 事件来显示自定义的上下文菜单，而使用onclick 事件处理程序来隐藏该菜单。
					例子的事件流程：
						这个事件处理程序首先会取消默认行为，以保证不显示浏览器默认的上下文菜单。
						然后，再根据event 对象clientX 和clientY 属性的值，来确定放置<ul>元素的位置。
						最后一步就是通过将visibility 属性设置为"visible"来显示自定义上下文菜单。
						另外，还为document 添加了一个onclick 事件处理程序，以便用户能够通过鼠标单击来隐藏菜单（单击也是隐藏系统上下文菜单的默认操作）。

				beforeunload 事件
					页面卸载前执行的函数

				DOMContentLoaded 事件
					window 的load 事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要加载的外部资源过多而颇费周折。
					而DOMContentLoaded 事件则在形成完整的DOM 树之后就会触发，不理会图像、JavaScript 文件、CSS 文件或其他资源是否已经下载完毕。
					与load 事件不同，DOMContentLoaded 支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面进行交互。
					例子：
						document.addEventListener('DOMContentLoaded', function (e) {console.log(e)}, false)

				readystatechange 事件（可以参考“JavaScript高级程序设计(第三版)” p408）
					每个对象都有一个 readyState 属性，可能包含下列5 个值中的一个。
						uninitialized（未初始化）：对象存在但尚未初始化。
						loading(正在加载)		对象正在加载数据。
						loaded(加载完毕)		对象加载数据完成。
						interactive（交互）		可以操作对象了，但还没有完全加载。
						complete（完成）		对象已经加载完毕。
					并非所有对象都会经历 readyState 的这几个阶段。

					这个事件有不稳定性，已知用来监听 document 加载周期， 和动态 js 的加载周期

				pageshow 和 pagehide 事件
					Firefox 和Opera 有一个特性，名叫“往返缓存”（back-forward cache，或bfcache），
					可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。
					这个缓存中不仅保存着页面数据，还保存了DOM 和JavaScript 的状态；实际上是将整个页面都保存在了内存里。

					因为这个特性，在页面重新显示出来时，不会执行 load，这个时候就需要：
						这两必需添加到 window 上
						e.persisted		该属性是个布尔值，来判断页面是否缓存中的页面
						pageshow		页面显示时执行，load 之后执行
						pagehide		页面隐藏时执行，unload 之前执行

				hashchange 事件
					在URL 的参数列表（及URL 中“#”号后面的所有字符串）发生变化时通知开发人员。
					必须要把hashchange 事件处理程序添加给window 对象

					window.addEventListener('hashchange', function (e) {console.log(e)})
					包含这两属性（兼容问题，最好用 location）
						e.newURL
						e.oldURL

			设备事件
				orientationchange 事件
					手机浏览器的查看模式切换时触发（主要是竖屏和横屏）
					可以把 orientationchange 事件处理程序添加给 window 对象或body元素
					window.orientation 表示手机的状态 0竖 90、-90 横屏

				deviceorientation 事件（可以参考“JavaScript高级程序设计(第三版)” p414）
					加速计检测到设备方向变化时在 window 对象上触发
					告诉开发人员设备在空间中朝向哪儿

				devicemotion 事件（可以参考“JavaScript高级程序设计(第三版)” p417）
					这个事件是要告诉开发人员设备什么时候移动，而不仅仅是设备方向如何改变。

			触摸与手势事件
				触摸事件
					touchstart		当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。
					touchmove		当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用 preventDefault() 可以阻止滚动。
						// touch-action: none	阻止默认事件需要给元素加这样式
					touchend		当手指从屏幕上移开时触发。
					touchcancel		当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。

					上面这几个事件都会冒泡，也都可以取消。 event 对象都提供了在鼠标事件中常见的属性

					除了常见的DOM属性外，触摸事件还包含下列三个用于跟踪触摸的属性。
					touches				表示当前跟踪的触摸操作的Touch 对象的数组。
					targetTouchs		特定于事件目标的Touch 对象的数组。
					changeTouches		表示自上次触摸以来发生了什么改变的Touch 对象的数组。

					每个 Touch（e.touches[0] || e.changedTouches[0]） 对象包含下列属性。
					clientX				触摸目标在视口中的x 坐标。
					clientY				触摸目标在视口中的y 坐标。
					identifier			标识触摸的唯一ID。
					pageX				触摸目标在页面中的x 坐标。
					pageY				触摸目标在页面中的y 坐标。
					screenX				触摸目标在屏幕中的x 坐标。
					screenY				触摸目标在屏幕中的y 坐标。
					target				触摸的DOM 节点目标。

				手势事件（可以参考“JavaScript高级程序设计(第三版)” 13.4.9 )
					gesturestart		当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发。
					gesturechange		当触摸屏幕的任何一个手指的位置发生变化时触发。
					gestureend			当任何一个手指从屏幕上面移开时触发。

	
		内存和性能（可以参考“JavaScript高级程序设计(第三版)” 13.5 )
			事件委托
				利用 addEventListener 的冒泡机制，给父元素添加事件，触发子元素会冒泡上去。

			移除事件处理程序
				使用 innerHTML 时，注意替换的内容里是否包含事件，要清楚(赋值为null)
				通过 onunload 事件来清楚，一般页面在前进和后退都会被缓存下来

			有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户感觉页面反应不够灵敏。
			建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。
			建议在浏览器卸载页面之前移除页面中的所有事件处理程序。

		模拟事件（可以参考“JavaScript高级程序设计(第三版)” 13.6 )
			DOM中的事件模拟
				document.createEvent() 通过这方法创建事件中的 event 对象
				这个方法接收一个参数，即表示要创建的事件类型的字符串。
					UIEvents				一般化的UI 事件。鼠标事件和键盘事件都继承自UI 事件。DOM3 级中是UIEvent。
					MouseEvents				一般化的鼠标事件。DOM3 级中是MouseEvent。
					MutationEvents			一般化的DOM 变动事件。DOM3 级中是MutationEvent。
					HTMLEvents				一般化的HTML 事件。没有对应的DOM3 级事件（HTML 事件被分散到其他类别中）。

				document.dispatchEvent() 通过这方法触发事件
				这个方法接收一个参数，传 event 对象。

				例子：（主动触发事件）
					const btn = document.getElementById('myBtn');
					btn.onclick = (e: IParameter) => {
						console.log(e);
					};
					const evnet = document.createEvent('MouseEvents');
					evnet.initMouseEvent('click', true, true, document.defaultView, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
					btn.dispatchEvent(evnet);

				自定义DOM 事件
					只能通过模拟事件来进行触发
					CustomEvent			创建自定义事件的字符串

					const btn = document.getElementById('myBtn');
					btn.addEventListener('myevent', (e) => {
						console.log(e);
					}, false);

					const event = document.createEvent('CustomEvent');
					event.initCustomEvent('myevent', true, false, 'hhhhhhh');
					btn.dispatchEvent(event);

			IE中的事件模拟

	表单脚本
		表单的基础知识
			表单是由<form>元素来表示的，而在JavaScript 中，表单对应的则是 HTMLFormElement 类型
			属性
				acceptCharset		服务器能够处理的字符集；等价于HTML 中的accept-charset 特性。
				action				接受请求的URL；等价于HTML 中的action 特性。
				elements			表单中所有控件的集合（HTMLCollection）。
				enctype				请求的编码类型；等价于HTML 中的enctype 特性。
				length				表单中控件的数量。
				method				要发送的HTTP 请求类型，通常是"get"或"post"；等价于HTML 的method 特性。
				name				表单的名称；等价于HTML 的name 特性。
				reset()				将所有表单域重置为默认值。
				submit()			提交表单。
				target				用于发送请求和接收响应的窗口名称；等价于HTML 的target 特性。

				html5 
				autofocus			不用 JavaScript 就能自动把焦点移动到相应字段

			document.forms 可以获取到页面中所有的 form 表单。

			提交表单
				<!-- 通用提交按钮 -->
				<input type="submit" value="Submit Form">
				<!-- 自定义提交按钮 -->
				<button type="submit">Submit Form</button>
				<!-- 图像按钮 -->
				<input type="image" src="graphic.gif">
				document.forms[0].submit();
				e.preventDefault(); 可以阻止默认事件

			重置表单
				<!-- 通用重置按钮 -->
				<input type="reset" value="Reset Form">
				<!-- 自定义重置按钮 -->
				<button type="reset">Reset Form</button>
				document.forms[0].reset();
				e.preventDefault(); 可以阻止默认事件

			表单字段
				document.forms[0].elements; 可以通过 name 值获取对应的元素

				共有的表单字段属性
					disabled			布尔值，表示当前字段是否被禁用。
					form				指向当前字段所属表单的指针；只读。
					name				当前字段的名称。
					readonly			布尔值，表示当前字段是否只读。
					tabindex			表示当前字段的切换（tab）序号。
					type				当前字段的类型，如"checkbox"、"radio"，等等。
					value				当前字段将被提交给服务器的值。对文件字段来说，这个属性是只读的，包含着文件在计算机中的路径。

				共有的表单字段方法
					focus()				获取焦点
					blur()				失去焦点

				共有的表单字段事件
					blur				当前字段失去焦点时触发。
					change				对于<input>和<textarea>元素，在它们失去焦点且value 值改变时触发；对于<select>元素，在其选项改变时触发。
					focus				当前字段获得焦点时触发。
		
		文本框脚本
			<input>
			<textarea>
			在处理文本框的值时，最好不要使用DOM 方法。

			选择文本
				select()方法		选择文本框中的所有文本
				例子：document.forms[0].elements[0].select()

				选择（select）事件
					与select()方法对应的，是一个select 事件。在选择了文本框中的文本时，就会触发select事件。

				取得选择的文本
					属性
					selectionStart
					selectionEnd

				选择部分文本 （兼容，可以参考“JavaScript高级程序设计(第三版)” 14.2.1 )
					setSelectionRange()		类似于截取字符串
					document.forms[0].elements[0].setSelectionRange(0, 5)

			过滤输入
				keypress		利用该事件来监听按钮 charCode 进行过滤，preventDefault() 可以阻止输入文本
				例子：
					_keypress (e: IParameter) {
						console.log(e.charCode);
						if (!/\d/.test(String.fromCharCode(e.charCode)) && e.charCode > 9 && !e.ctrlKey) {
							e.preventDefault();
						}
					}

			操作剪贴板
				beforecopy			在发生复制操作前触发。
				copy				在发生复制操作时触发。
				beforecut			在发生剪切操作前触发。
				cut					在发生剪切操作时触发。
				beforepaste			在发生粘贴操作前触发。
				paste				在发生粘贴操作时触发。

			自动切换焦点
				(function () {
					function tabForward(event) {
						event = EventUtil.getEvent(event);
						var target = EventUtil.getTarget(event);
						if (target.value.length == target.maxLength) {
							var form = target.form;
							for (var i = 0, len = form.elements.length; i < len; i++) {
								if (form.elements[i] == target) {
									if (form.elements[i + 1]) {
										form.elements[i + 1].focus();
									}
									return;
								}
							}
						}
					}
					var textbox1 = document.getElementById("txtTel1");
					var textbox2 = document.getElementById("txtTel2");
					var textbox3 = document.getElementById("txtTel3");
					EventUtil.addHandler(textbox1, "keyup", tabForward);
					EventUtil.addHandler(textbox2, "keyup", tabForward);
					EventUtil.addHandler(textbox3, "keyup", tabForward);
				})();

			HTML5 约束验证API
				表单属性
				noValidate			给表单设置该属性，禁用验证
				formNoValidate		给表单提交按钮设置该属性，提交时禁用验证
				required			必填
				pattern				是一个正则表达式
					<input type="text" pattern="\d+" name="count"> 注意，模式的开头和末尾不用加^和$符号（假定已经有了）。

				step			每次增加或减少的值
					<input type="number" min="0" max="100" step="5" name="count">
					这两个方法可以模拟
					stepUp()
					stepDown()

				表单控件验证属性
				validity		是个对象，包含着
					例子document.forms[0].elements[0].validity
					customError				如果设置了 setCustomValidity()，则为true，否则返回false。
					patternMismatch			如果值与指定的pattern 属性不匹配，返回true。
					rangeOverflow			如果值比max 值大，返回true。
					rangeUnderflow			如果值比min 值小，返回true。
					stepMisMatch			如果min 和max 之间的步长值不合理，返回true。
					tooLong					如果值的长度超过了maxlength 属性指定的长度，返回true。有的浏览器（如Firefox 4）会自动约束字符数量，因此这个值可能永远都返回false。
					typeMismatch			如果值不是"mail"或"url"要求的格式，返回true。
					valid					如果这里的其他属性都是false，返回true。checkValidity()也要求相同的值。
					valueMissing			如果标注为required 的字段中没有值，返回true。

				input 的其他输入类型（type）
					type="email"
					type="url"
					number
					range
					datetime
					atetime-local
					date
					month
					week
					time

				检测有效性
					document.forms[0].elements[0].checkValidity()		针对于表单中字段
					document.forms[0].checkValidity()					针对于整个表单

		选择框脚本
			选择框是通过<select>和<option>元素创建的
			HTMLSelectElement 类型还提供了下列属性和方法
			add(newOption, relOption)			向控件中插入新<option>元素，其位置在相关项（relOption）之前。
			multiple							布尔值，表示是否允许多项选择；等价于HTML 中的multiple 特性。
			options								控件中所有<option>元素的HTMLCollection。
			remove(index)						移除给定位置的选项。
			selectedIndex						基于0 的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件，只保存选中项中第一项的索引。
			size								选择框中可见的行数；等价于HTML 中的size 特性。（影响部分功能）

			HTMLOptionElement 对象添加了下列属属性：
			index				当前选项在options 集合中的索引。
			label				当前选项的标签；等价于HTML 中的label 特性。
			selected			布尔值，表示当前选项是否被选中。将这个属性设置为true 可以选中当前选项。
			text				选项的文本。
			value				选项的值（等价于HTML 中的value 特性）。

			创建 option （等同于 HTMLOptionElement，ie 不能用）
				const o = new Option('text', 'value');

		表单序列化
			function serialize(form) {
				var parts = [],
					field = null,
					i,
					len,
					j,
					optLen,
					option,
					optValue;
				for (i = 0, len = form.elements.length; i < len; i++) {
					field = form.elements[i];
					switch (field.type) {
						case "select-one":
						case "select-multiple":
							if (field.name.length) {
								for (j = 0, optLen = field.options.length; j < optLen; j++) {
									option = field.options[j];
									if (option.selected) {
										optValue = "";
										if (option.hasAttribute) {
											optValue = (option.hasAttribute("value") ?
												option.value : option.text);
										} else {
											optValue = (option.attributes["value"].specified ?
												option.value : option.text);
										}
										parts.push(encodeURIComponent(field.name) + "=" +
											encodeURIComponent(optValue));
									}
								}
							}
							break;
						case undefined: //字段集
						case "file": //文件输入
						case "submit": //提交按钮
						case "reset": //重置按钮
						case "button": //自定义按钮
							break;
						case "radio": //单选按钮
						case "checkbox": //复选框
							if (!field.checked) {
								break;
							}
						/* 执行默认操作 */
						default:
							//不包含没有名字的表单字段
							if (field.name.length) {
								parts.push(encodeURIComponent(field.name) + "=" +
									encodeURIComponent(field.value));
							}
					}
				}
				return parts.join("&");
			}

		富文本编辑（可以参考“JavaScript高级程序设计(第三版)” 14.5 )

	使用Canvas 绘图（可以参考“JavaScript高级程序设计(第三版)” 15 )

	HTML5 脚本编程（可以参考“JavaScript高级程序设计(第三版)” 16 )

	错误处理与调试
		浏览器报告的错误（可以参考“JavaScript高级程序设计(第三版)” 17.1 )
			主要是讲针对各浏览器的调试方法

		错误处理
			try-catch语句
			try-catch-finally
				只要代码中包含finally 子句，那么无论try 还是catch 语句块中的return 语句都将被忽略。
				因此，在使用finally 子句之前，一定要非常清楚你想让代码怎么样。

			抛出错误
				throw 操作符，用于随时抛出自定义错误
				例子：
					throw 12345;
					throw "Hello world!";
					throw true;
					throw { name: "JavaScript"};

					throw new Error("syntax.");
					throw new SyntaxError("I don’t like your syntax.");
					throw new TypeError("What type of variable do you take me for?");
					throw new RangeError("Sorry, you just don’t have the range.");
					throw new EvalError("That doesn’t evaluate.");
					throw new URIError("Uri, is that you?");
					throw new ReferenceError("You didn’t cite your references properly.");

				区别浏览器的错误，可以通过创建自定义错误（原型链继承）
					function CustomError(message){
						this.name = "CustomError";
						this.message = message;
					}
					CustomError.prototype = new Error();
					throw new CustomError("My message");

				注意：一旦使用 throw 操作符，代码就会停止执行，除非用 try-catch语句 捕获错误
				捕获错误的目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。

			错误（error）事件
				window.onerror = function (message, url, line) {
					// 信息，文档url，行号
					return false;
				}

				通过返回false，这个函数实际上就充当了整个文档中的try-catch 语句，可以捕获所有无代码处理的运行时错误。

			处理错误的策略
				作为开发人员，必须要知道代码何时可能出错，会出什么错，同时还要有一个跟踪此类问题的系统。

			常见的错误类型（可以参考“JavaScript高级程序设计(第三版)” 17.2.5 )
				一般来说，需要关注三种错误：
					类型转换错误
					数据类型错误
					通信错误

			区分致命错误和非致命错误（可以参考“JavaScript高级程序设计(第三版)” 17.2.6 )

			把错误记录到服务器（可以参考“JavaScript高级程序设计(第三版)” 17.2.7 )

		调试技术
			将消息记录到控制台
				console 对象向JavaScript 控制台中写入消息
					error(message)		将错误消息记录到控制台
					info(message)		将信息性消息记录到控制台
					log(message)		将一般消息记录到控制台
					warn(message)		将警告消息记录到控制台

			将消息记录到当前页面

			抛出错误
				function assert(condition, message) {
					if (!condition){
						throw new Error(message);
					}
				}

				function divide(num1, num2) {
					assert(typeof num1 == "number" && typeof num2 == "number", "divide(): Both arguments must be numbers.");
					return num1 / num2;
				}

		常见的IE 错误（可以参考“JavaScript高级程序设计(第三版)” 17.4 )

	JavaScript 与XML（可以参考“JavaScript高级程序设计(第三版)” 18 )

	E4X（可以参考“JavaScript高级程序设计(第三版)” 19 )

	JSON（可以参考“JavaScript高级程序设计(第三版)” 20 )
		JSON.stringify()		输出的JSON 字符串不包含任何空格字符或缩进
			还可以接收另外两个参数
			第一个参数是个过滤器，可以是一个数组，也可以是一个函数；
				传数组时取数组的字段并按上面的顺序来
					var jsonText = JSON.stringify(book, ["title", "edition"]);
				传函数
					var jsonText = JSON.stringify(book, function(key, value){
						// 返回undefined，则表示要从结果中删除相应的键
						return value;
					});
			第二个参数是一个选项，表示是否在JSON 字符串中保留缩进。
				JSON.stringify(book, null, 4);
				JSON.stringify(book, null, '--');
			有一个扩展函数 toJSON ，需要自定义（可以参考“JavaScript高级程序设计(第三版)” 20.2.2(3) )

		JSON.parse()			JSON 字符串转化成js 里的对象
			接收另一个参数，该参数是一个函数
			var book = {date: new Date(2011, 11, 1)};
			JSON.parse(JSON.stringify(book), function(key, value){
				// 返回undefined，则表示要从结果中删除相应的键
				if (key == "date"){
					return new Date(value);
				} else {
					return value;
				}
			});

		值为undefined 的任何属性也都会被跳过。结果中最终都是值为有效JSON 数据类型的实例属性。

		JSON 是一个轻量级的数据格式，可以简化表示复杂数据结构的工作量。

	Ajax 与Comet（可以参考“JavaScript高级程序设计(第三版)” 21 )
		var xhr = new XMLHttpRequest();
		XMLHttpRequest 对象
			兼容 ie7及更早的版本（可以参考“JavaScript高级程序设计(第三版)” 21。1 开头的那部分)

			XHR的用法
				xhr.open()			它接受 3 个参数：要发送的请求的类型（"get"、 "post"等）、请求的 URL 和表示是否异步发送请求的布尔值。
					xhr.open("get", "example.php", true);
				xhr.send()			接收一个参数，即要作为请求主体发送的数据。
									如果不需要通过请求主体发送数据，则必须传入 null，因为这个参数对有些浏览器来说是必需的。
									调用 send()之后，请求就会被分派到服务器
				xhr.abort()			对已发送的请求，进行中止，之后，还应该对 XHR 对象进行解引用操作。（就是赋值为 null）

				
				xhr	属性
					xhr.readyState
						0		未初始化。尚未调用 open()方法。
						1		启动。已经调用 open()方法，但尚未调用 send()方法。
						2		发送。已经调用 send()方法，但尚未接收到响应。
						3		接收。已经接收到部分响应数据。
						4		完成。已经接收到全部响应数据，而且已经可以在客户端使用了。
				
				xhr 方法
					xhr.onreadystatechange		readyState 每次变化都会触发该函数，该函数必须在调用open() 之前定义
						xhr.onreadystatechange = function(){
							if (xhr.readyState == 4){
								if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
									alert(xhr.responseText);
								} else {
									alert("Request was unsuccessful: " + xhr.status);
								}
							}
						};

				注意：请求的URL 必须和网站域名相同，否则就会涉及到跨域问题
				状态码：
					200		作为成功的标识
					304		表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本；当然，也意味着响应是有效的
			
			HTTP头部信息
				每个 HTTP 请求和响应都会带有相应的头部信息，其中有的对开发人员有用，有的也没有什么用。
				XHR 对象也提供了操作这两种头部（即请求头部和响应头部）信息的方法。
				默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。
					Accept						浏览器能够处理的内容类型。
					Accept-Charset				浏览器能够显示的字符集。
					Accept-Encoding				浏览器能够处理的压缩编码。
					Accept-Language				浏览器当前设置的语言。
					Connection					浏览器与服务器之间连接的类型。
					Cookie						当前页面设置的任何 Cookie。
					Host						发出请求的页面所在的域 。
					Referer						发出请求的页面的 URI。
												注意， HTTP 规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。（这个英文单词的正确拼法应该是 referrer。）
					User-Agent					浏览器的用户代理字符串。

				xhr.setRequestHeader()			设置请求头部信息作用，接受两个参数，头部字段的名称和头部字段的值。必须在调用open() 之后，send() 之前调用
				xhr.getResponseHeader()			传头部字段，获取对应的值
				xhr.getAllResponseHeaders()		获取包含所有头部信息的长字符串


				注意：不要随意使用浏览器自带的字段，有的浏览器允许重写，有的不允许

			GET请求
				将查询字符串参数追加到 URL 的末尾，然后将信息发送给服务器。
				查询字符串中每个参数的名称和值都必须使用 encodeURIComponent()进行编码，然后才能放到 URL 的末尾；而且所有名-值对儿都必须由和号（&）分隔

			POST请求
				模仿表单提交，最主要是设置请求头，和发送过去的数据。
				xhr.open("post", "example.php", true);
				xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
				xhr.send('a=1&b=2&c=3');

			get 发送速度会比 post 快，但 post 也接受更多数据，相对的安全点。
		
		XMLHttpRequest 2 级
			FormData
				var data = new FormData();
				FormData 为序列化表单以及创建与表单格式相同的数据（用于通过XHR 传输）提供了便利。
				方法：
				data.append()		接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值。(可以添加多个)
				
				通过 append 设置值
					data.append("name", "Nicholas");
				通过构造函数
					data = new FormData(document.forms[0]);

				使用FormData 的方便之处体现在不必明确地在XHR 对象上设置请求头部。
				XHR 对象能够识别传入的数据类型是FormData 的实例，并配置适当的头部信息。

				注意：可以用来模仿表单提交图片

			超时设定
				xhr.timeout			超时时间
					xhr.timeout = 1000;
					xhr.ontimeout = function () {
						alert('//将超时设置为1 秒钟');
					}

				注意：超时后readyState 会变为4，就会触发onreadystatechange。因为超时了，所以正常执行会报错，可以加个try-cacth。
			
			overrideMimeType()
				响应的MIME 类型决定了XHR 对象如何处理它，所以提供一种方法能够重写服务器返回的MIME 类型是很有用的。
				xhr.overrideMimeType("text/xml");

				这个例子强迫XHR 对象将响应当作XML 而非纯文本来处理。
				调用overrideMimeType() 必须在send() 方法之前，才能保证重写响应的MIME 类型。

				注意：感觉用不到

		进度事件
			事件
				onloadstart			在接收到响应数据的第一个字节时触发。
				onprogress			在接收响应期间持续不断地触发。
				onerror				在请求发生错误时触发。
				onabort				在因为调用abort()方法而终止连接时触发。
				onload				在接收到完整的响应数据时触发。
				onloadend				在通信完成或者触发error、abort 或load 事件后触发。

			onload事件（为确保正常执行，必须在调用open()方法之前添加onload 事件处理程序）
				用来代替readystatechange 事件，响应接收完后会触发load，因此没有必要去检查readyState 属性了。
				onload 事件接收event 对象，event.target 指向XHR 实例对象。（兼容问题，还是直接使用实例对象(xhr)，不要用event 对象）
				例子：
					xhr.onload = function(){
						if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
							alert(xhr.responseText);
						} else {
							alert("Request was unsuccessful: " + xhr.status);
						}
					};

				注意：
					只要浏览器接收到服务器的响应，不管其状态如何，都会触发load 事件。
					而这意味着你必须要检查status 属性，才能确定数据是否真的已经可用了。

			onprogress事件（为确保正常执行，必须在调用open()方法之前添加onprogress 事件处理程序）
				onprogress 事件接收event 对象，event.target 指向XHR 实例对象。
				三个额外的属性:
					lengthComputable		是一个表示进度信息是否可用的布尔值
					position 				表示已经接收的字节数
					totalSize 				表示根据Content-Length 响应头部确定的预期字节数
				
				例子：
					xhr.onprogress = function(event){
						if (event.lengthComputable){
							console.log("Received " + event.position + " of " + event.totalSize +" bytes");
						}
					};

		跨源资源共享
			通过XHR 实现Ajax 通信的一个主要限制，来源于跨域安全策略。
			默认情况下，XHR 对象只能访问与包含它的页面位于同一个域中的资源
			CORS（Cross-Origin Resource Sharing，跨源资源共享）

			IE对CORS的实现（可以参考“JavaScript高级程序设计(第三版)” 21.4.1 )
				微软在IE8 中引入了XDR（XDomainRequest）类型。这个对象与XHR 类似，但能实现安全可靠的跨域通信。

			其他浏览器对CORS的实现
				通过XMLHttpRequest 对象实现了对CORS 的原生支持

				与IE 中的XDR 对象不同，通过跨域XHR 对象可以访问status 和statusText 属性，而且还支持同步请求。
				跨域XHR 对象也有一些限制，但为了安全这些限制是必需的。
				以下就是这些限制。
					不能使用setRequestHeader()设置自定义头部。
					不能发送和接收cookie。
					调用getAllResponseHeaders()方法总会返回空字符串。

			Preflighted Reqeusts（可以参考“JavaScript高级程序设计(第三版)” 21.4.3 )
				CORS 通过一种叫做Preflighted Requests 的透明服务器验证机制支持开发人员使用自定义的头部、GET 或POST 之外的方法，以及不同类型的主体内容。
				在使用下列高级选项来发送请求时，就会向服务器发送一个Preflight 请求。
				这种请求使用OPTIONS 方法，发送下列头部。
					Origin									与简单的请求相同。
					Access-Control-Request-Method			请求自身使用的方法。
					Access-Control-Request-Headers			(可选)自定义的头部信息，多个头部以逗号分隔。
															以下是一个带有自定义头部NCZ 的使用POST 方法发送的请求。

				发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。
					Access-Control-Allow-Origin				与简单的请求相同。
					Access-Control-Allow-Methods			允许的方法，多个方法以逗号分隔。
					Access-Control-Allow-Headers			允许的头部，多个头部以逗号分隔。
					Access-Control-Max-Age					应该将这个Preflight 请求缓存多长时间（以秒表示）。

			带凭据的请求（可以参考“JavaScript高级程序设计(第三版)” 21.4.4 )

			跨浏览器的CORS（可以参考“JavaScript高级程序设计(第三版)” 21.4.5 )

		其他跨域技术（可以参考“JavaScript高级程序设计(第三版)” 21.5 )
			图像Ping
			JSONP
			Comet（通信，单向）
			服务器发送事件（通信，单向）
			Web Sockets（通信，双向）
			SSE与Web Sockets


			短轮询			设置定时器循环请求
			长轮询			发起请求后，一直等待到有数据返回
			HTTP 流			这个是利用 readyState状态为3 和 onreadystatechange事件来处理。
							只要请求连接保持不断开，然后每次一点一点的把数据扔出来
		
		安全（可以参考“JavaScript高级程序设计(第三版)” 21.6 )

	高级技巧
		高级函数
			安全的类型检测
				typeof 操作符吧，由于它有一些无法预知的行为，经常会导致检测数据类型时得到不靠谱的结果。
				instanceof 当拿不同 iframe 里的值，在当前的 iframe 里进行判断会出现问题。
				分不清是否原生对象。
				等等一系列问题会导致类型检测不靠谱

				解决方法：
					Object.prototype.toString.call([]);  // "[object Array]"
					Object.prototype.toString.call(/\d/);  // "[object RegExp]"
					对于非原生对象，统一返回 "[object Object]"，由此来推断该对象是否原生
					这些都是基于 toString 没有被修改。

			作用域安全的构造函数
				当没有判断的时候，构造函数被直接调用，this 会指向最近的作用域上，可能会覆盖原作用域上的属性。
				加了判断，构造函数更安全，首先确认this 对象是正确类型的实例。如果不是，那么会创建新的实例并返回。
				function Person(name, age, job){
					if (this instanceof Person){
						this.name = name;
						this.age = age;
						this.job = job;
					} else {
						return new Person(name, age, job);
					}
				}

				提示
					实现这个模式后，你就锁定了可以调用构造函数的环境。
					如果你使用构造函数 窃取模式的继承（就是使用call 或apply 进行继承） 且不使用原型链，那么这个继承很可能被破坏。

			惰性载入函数
				为了兼容代码每次执行都会进行检测，检测只需要一次，就能知道应该使用哪个部分的代码
				平常的写法会每次执行都检测。
				但用了惰性载入，判断一次后把函数重写了，以后的调用就不需要再进行判断。

				第一种
				function createXHR() {
					if (typeof XMLHttpRequest != "undefined") {
						createXHR = function () {
							return new XMLHttpRequest();
						};
					} else if (typeof ActiveXObject != "undefined") {
						createXHR = function () {
							if (typeof arguments.callee.activeXString != "string") {
								var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"],
									i, len;
								for (i = 0, len = versions.length; i < len; i++) {
									try {
										new ActiveXObject(versions[i]);
										arguments.callee.activeXString = versions[i];
										break;
									} catch (ex) {
										//skip
									}
								}
							}
							return new ActiveXObject(arguments.callee.activeXString);
						};
					} else {
						createXHR = function () {
							throw new Error("No XHR object available.");
						};
					}
					return createXHR();
				}

				第二种
				var createXHR = (function () {
					if (typeof XMLHttpRequest != "undefined") {
						return function () {
							return new XMLHttpRequest();
						};
					} else if (typeof ActiveXObject != "undefined") {
						return function () {
							if (typeof arguments.callee.activeXString != "string") {
								var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0",
										"MSXML2.XMLHttp"
									],
									i, len;
								for (i = 0, len = versions.length; i < len; i++) {
									try {
										new ActiveXObject(versions[i]);
										arguments.callee.activeXString = versions[i];
										break;
									} catch (ex) {
										//skip
									}
								}
							}
							return new ActiveXObject(arguments.callee.activeXString);
						};
					} else {
						return function () {
							throw new Error("No XHR object available.");
						};
					}
				})();

			函数绑定
				function a () {};
				就是给函数里的this 绑定上指定的对象
					function bind(fn, context) {
						return function(){
							return fn.apply(context, arguments);
						};
					}
					bind(a, window);

				es5 给函数添加了 bind() 函数
					a.bind(window);

				注意
					被绑定函数与普通函数相比有更多的开销，它们需要更多内存，同时也因为多重函数调用稍微慢一点，所以最好只在必要时使用。

			函数柯里化

		防篡改对象
			不可扩展对象
				Object.istExtensible()				确定对象是否可扩展（注意：应该被抛弃了）
				Object.preventExtensions()			使对象不能进行扩展（严格模式下进行扩展会抛出异常，但可以对原有的值进行修改和删除）

				例子：
					var person = { name: "Nicholas" };
					Object.preventExtensions(person);
					person.age = 29;
					alert(person.age); //undefined

			密封的对象
				Object.seal()				密封对象
				Object.isSealed()			确定对象是否被密封了

			冻结的对象
				Object.freeze()				冻结的对象既不可扩展，又是密封的，而且对象数据属性的[[Writable]]特性会被设置为false
				Object.isFrozen()			确定对象是否被冻结了

		高级定时器
			关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。
			如果前面例子中的onclick 事件处理程序执行了300ms，那么定时器的代码至少要在定时器设置之后的300ms 后才会被执行。
			队列中所有的代码都要等到JavaScript 进程空闲之后才能执行，而不管它们是如何添加到队列中的

			重复的定时器（可以参考“JavaScript高级程序设计(第三版)” 22.3.1 )
				setTimeout(function(){
					//处理中
					setTimeout(arguments.callee, interval);
				}, interval);
				代替
				setInterval()

			Yielding Processes（可以参考“JavaScript高级程序设计(第三版)” 22.3.2 )
				循环数据量大的数组时，使用数组分块处理

            函数节流
                对dom的频繁操作进行延时处理
                    function throttle(method, context) {
                        clearTimeout(method.tId);
                        method.tId= setTimeout(function(){
                            method.call(context);
                        }, 100);
                    }

        自定义事件（可以参考“JavaScript高级程序设计(第三版)” 22.4 )

        拖放（可以参考“JavaScript高级程序设计(第三版)” 22.5 )
            例子：追随鼠标移动，给文档添加 mousemove(鼠标移动触发) 事件
            document.addEventListener('mousemove', function (event) {
                var myDiv = document.getElementById("myDiv");
                myDiv.style.left = event.clientX + "px";
                myDiv.style.top = event.clientY + "px";
            });

    离线应用与客户端存储

        离线检测
            navigator.onLine        判断设备是否联网

            设备从离线到联网会触发
            window.addEventListener('online', () => {console.log(1)})

            设备从联网到离线会触发
            window.addEventListener('offline', () => {console.log(2)})

        应用缓存

        数据存储
            cookie
                限制
                    同域名下 cookie 会随请求发送给服务器
                    最好将整个cookie 长度限制在4095B（含4095）以内
                构成
                    名称
                    值
                    域                  限制同域名下才能访问
                    路径                限制在某个路径下的请求才能访问到改cookie
                    失效时间            
                    安全标志            不懂
                
                封装（可以参考“JavaScript高级程序设计(第三版)” 23.3.1 有着更详细的封装)
                var CookieUtil = {
                    get: function (name) {
                        var cookieName = encodeURIComponent(name) + "=",
                            cookieStart = document.cookie.indexOf(cookieName),
                            cookieValue = null;
                        if (cookieStart > -1) {
                            var cookieEnd = document.cookie.indexOf(";", cookieStart);
                            if (cookieEnd == -1) {
                                cookieEnd = document.cookie.length;
                            }
                            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart
                                + cookieName.length, cookieEnd));
                        }
                        return cookieValue;
                    },
                    set: function (name, value, expires, path, domain, secure) {
                        var cookieText = encodeURIComponent(name) + "=" +
                            encodeURIComponent(value);
                        if (expires instanceof Date) {
                            cookieText += "; expires=" + expires.toGMTString();
                        }
                        if (path) {
                            cookieText += "; path=" + path;
                        }
                        if (domain) {
                            cookieText += "; domain=" + domain;
                        }
                        if (secure) {
                            cookieText += "; secure";
                        }
                        document.cookie = cookieText;
                    },
                    unset: function (name, path, domain, secure) {
                        this.set(name, "", new Date(0), path, domain, secure);
                    }
                };
        
            IE用户数据（可以参考“JavaScript高级程序设计(第三版)” 23.3.2)

            Web存储机制（可以参考“JavaScript高级程序设计(第三版)” 23.3  有特定于 ie8 的写法)
                
                Storage 类型提供最大的存储空间（因浏览器而异）来存储名值对儿。Storage 的实例与其他对象类似，有如下方法。
                    getItem(name)                   根据指定的名字name 获取对应的值。
                    setItem(name, value)            为指定的name 设置一个对应的值。
                    removeItem(name)                删除由name 指定的名值对儿。
                    clear()                         删除所有值；Firefox 中没有实现 。
                    key(index)                      获得index 位置处的值的名字。

                // sessionStorage instanceof Storage
                // true  说明是 Storage 实例化出来的
                sessionStorage      对象存储特定于某个会话的数据，也就是该数据只保持到浏览器关闭。
                localStorage        会永久存储，除非主动删除

                对于 sessionStorage 而言，大多数桌面浏览器会设置每个来源2.5MB 的限制。
                对于 localStorage 而言，大多数桌面浏览器会设置每个来源5MB 的限制。移动端大多是2.5MB 的限制。

            IndexedDB（可以参考“JavaScript高级程序设计(第三版)” 23.3.4)

    最佳实践（可以参考“JavaScript高级程序设计(第三版)” 24)
        用单个字符表示基本类型："o"代表对象，"s"代表字符串，"i"代表整数，"f"代表浮点数，"b"代表布尔型。
            //用于指定数据类型的匈牙利标记法
            var bFound;     //布尔型
            var iCount;     //整数
            var sName;      //字符串
            var oPerson;    //对象















