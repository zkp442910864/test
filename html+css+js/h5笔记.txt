http://www.json.org/去下载json2.js   兼容



H5:
语义化标签：
	<header></header> 页眉 
	<hgroup></hgroup> 页面上的一个标题组合  h1-6写里面
	<nav></nav> 导航 
	<section> </section> 页面上的版块
	<footer></footer>页脚  
	<article></ article >定义一个文章区域      用来在页面中表示一套结构完整且独立的内容部分
		可以用来呈现论坛的一个帖子，杂志或报纸中的一篇文章，一篇博客，用户提交的评论内容，可互动的页面模块挂件等。
	<aside></ aside>定义页面的侧边栏内容      元素标签可以包含与当前页面或主要内容相关的引用、侧边栏、广告、nav元素组
	<figure> </ figure > 规定独立的流内容（图像、图表、照片、代码等等）。     用于对元素进行组合。一般用于图片或视频
	<figcaption> </ figcaption> 定义<figure> 元素的标题    figure的子元素 用于对figure的内容 进行说明
	<time></time> 用来表现时间或日期
	<datalist></datalist>选项列表  与 input 元素配合使用，来定义 input 可能的值。
		例：<input type="text" list="valList" />
			<datalist id="valList">
				<option value="javascript">javascript</option>
				<option value="html">html</option>
				<option value="css">css</option>
			</datalist>
	<details></details> 用于描述文档或文档某个部分的细节    *通过点击展示详细信息   FF不兼容
	< summary></summary> details 元素的标题
	<dialog></dialog> 定义一段对话   子标签dt、dd   chrome不支持
	<address></address> 定义文章 或页面作者的详细联系信息    字体是倾斜
	<mark></mark> 需要标记的词或句子   定义带有记号的文本。请在需要突出显示文本时使用该标签。
	<keygen>给表单添加一个公钥      *不懂
	<progress></progress>定义进度条
	
	*在不兼容的情况下，我们可以通过javascript在页面的头部创建标签
		例：<script>document.createElement(“header”);</script>
			我们用js创建出来之后，他是不会有任何默认样式的甚至是 display，所以在样式表里 要对这些标签定义一下 它默认的display

音频和视频标签：
	<audio> 定义声音内容
		例: <!--音频控件  controls IE不支持 -->
			<audio src="johann_sebastian_bach_air.mp3" autoplay="autoplay" controls="controls" loop="loop" ></audio>
			
	<video> 定义视频
		例: <!--视频控件-->
			<!--<video src="Intermission-Walk-in_512kb.mp4" controls="controls"></video>-->
			<!--格式兼容的时候，可以通过source标签指定不同的视频格式-->
			<video controls="controls" >
				<source src="Intermission-Walk-in_512kb.mp4"></source>
				<source src="Intermission-Walk-in.ogv"></source>
				<source src="johann_sebastian_bach_air.ogg"></source>
			</video>
	
	Video额外特性 
		poster:视频播放前的预览图片
		width、height:设置视频的尺寸
		videoWidth、videoHeight:视频的实际尺寸(只读)
	
	媒体元素 
		controls:显示或隐藏用户控制界面
		autoplay:媒体是否自动播放
		loop:媒体是否循环播放
		currentTime:开始到播放现在所用的时间
		duration:媒体总时间(只读)
		volume:0.0-1.0的音量相对值
		muted:是否静音
		autobuffer:开始的时候是否缓冲加载，autoplay的时候，忽略此属性
		
		paused:媒体是否暂停(只读)
		ended:媒体是否播放完毕(只读)
		error:媒体发生错误的时候，返回错误代码 (只读)
		currentSrc:以字符串的形式返回媒体地址(只读)
		play():媒体播放
		pause():媒体暂停
		load():重新加载媒体


	视频与canvas结合,可以再结合自制播放器
		var oV = document.getElementById('vd');
		var oc = document.getElementById('ca');
		var ctx = oc.getContext('2d');
				
		//设置canvas宽高
		oc.width = oV.videoWidth;
		oc.height = oV.videoHeight;
				
		setInterval(function(){
			//参数1：视频对象   参数2：绘制位置
			ctx.drawImage(oV,0,0);
		},10);

全局属性
	contenteditable		规定元素内容是否是可编辑的
	例:<div contenteditable></div>  内容可编辑

	spellcheck 			此属性规定是否对元素内容进行拼写检查。 不懂
	
	contextmenu 		属性为元素规定上下文菜单。这个菜单会在用户右键点击元素时出现。目前没有任何主流浏览器支持 contextmenu 属性。（貌似无效）
	例:
		<p contextmenu="supermenu">本段落拥有一个名为 "supermenu" 的上下文菜单。这个菜单会在用户右键单击该段落时出现。</p>  
		<menu id="supermenu">
		  <command label="Step 1: Write Tutorial" onclick="doSomething()">
		  <command label="Step 2: Edit Tutorial" onclick="doSomethingElse()">
		</menu>

	

input：
	type属性-值：
	email:电子邮箱文本框
	tel:电话号码     *tel类型：本身不能实现验证，需要结合正则验证	pattern="/^\d{11}$/"
	url:网页的URL
	search:定义用于搜索的文本字段。
	range:特定范围内的数值选择器 	min、max、step( 步数 )
	number:只能包含数字的输入框
	color:颜色选择器
	datetime:显示完整日期
	datetime-local:显示完整日期，不含时区
	time:显示时间，不含时区
	date:显示日期
	week:显示周
	month:显示月
	
	属性：
	placeholder:输入框提示信息 
	autocomplete:是否提示用户输入过值      默认为on，关闭提示选择off
	autofocus:指定表单获取输入焦点
	list:为输入框构造一个选择列表配合datalist
	required:此项必填，不能为空
	Pattern:正则验证  pattern="\d{1,5}“
	Formaction：在submit里定义提交地址
	formnovalidate:关闭验证
	
	表单验证：
	Invalid事件:验证反馈 
	input.addEventListener('invalid',function(ev){},false)
		阻止默认验证：ev.preventDefault()
	
JavaScript:	
	选择器：
		querySelector       		
			document.querySelector('id,class,标签');							匹配选中的首个元素(id,class,标签)
			document.querySelector('[title=hello]')								通过属性值获取元素
		querySelectorAll				 获取的是元素数组
		getElementsByClassName			 通过class名来获取
	
	获取class列表classList
	classList属性
		length:class的长度
		add():添加class方法
		remove():删除class方法
		toggle():切换class方法 		class名有到没，没到有
	例：<div class="box1 box2 box3" id="box"></div>
		<script>
			var oDiv = document.getElementById('box');
			oDiv.classList.add('box4');
		</script>
	
	eval() 使用
		例：var a = 'function show(){alert(123)}';
			eval(a);
			
	JSON的新方法：
	parse():用于将一个 JSON 字符串转换为 JavaScript 对象。
		例：var jsonStr = '{"name":"小明"}';
			var json1 = JSON.parse(jsonStr);
			alert(json1.name);
			
	stringify():用于将 JavaScript 对象转换为 JSON 字符串。
		例：var json = {'name':123};
			var str = JSON.stringify(json);
			alert(str);
	
	深浅拷贝对象   h5\day1
		浅：共同控制一个对象
		深：控制各自的
	
	自定义属性	   h5\day1
		data-数据在jquery mobile中有着重要作用
		
	延迟加载JS
		defer:延迟加载
		async:异步加载

	历史管理	   h5\day1	 	HTML5第二课 p7
		onhashchange  当页面的hash值发生改变的时候调用
		history

	拖放事件 
		设置属性draggable为true
		拖拽元素事件:事件对象为被拖拽元素
		dragstart,拖拽前触发 
		drag,拖拽中，连续触发
		dragend,拖拽结束触发
		
		目标元素事件:事件对象为目标元素
		dragenter,进入目标元素触发，相当于mouseover
		dragover,进入目标、离开目标之间，连续触发
		dragleave,离开目标元素触发，相当于mouseout
		drop,在目标元素上释放鼠标触发					*drop触发的时候(dragover的时候阻止默认事件)
	
	位置信息
		地理位置
			经度  :   南北极的连接线
			纬度  :   东西连接的线
		位置信息从何而来
			IP地址
			GPS全球定位系统
			Wi-Fi无线网络
			基站

		地理位置对象	
			navigator.geolocation
			单次定位请求  ：getCurrentPosition(请求成功，请求失败，数据收集方式)
			请求成功函数
				经度:coords.longitude
				纬度:coords.latitude
				准确度:coords.accuracy
				海拔:coords.altitude
				海拔准确度:coords.altitudeAcuracy
				行进方向:coords.heading
				地面速度:coords.speed
				时间戳:new Date(position.timestamp)
	
			请求失败函数
				失败编号  ：code
				0:不包括其他错误编号中的错误
				1:用户拒绝浏览器获取位置信息
				2:尝试获取用户信息，但失败了
				3:设置了timeout值，获取位置超时了
				
			数据收集:json的形式
				enableHighAcuracy:更精确的查找，默认false
				timeout:获取位置允许最长时间，默认infinity
				maximumAge:位置可以缓存的最大时间，默认0

			多次定位请求:watchPosition(像setInterval)
				移动设备有用，位置改变才会触发
				配置参数:frequency 更新的频率
			关闭更新请求:clearWatch(像clearInterval)
	
			例:
				//单次定位请求			getCurrentPosition
				navigator.geolocation.getCurrentPosition(function(position){
					oText.value += "经度："+position.coords.longitude + '\n';
					oText.value +="纬度："+ position.coords.latitude + '\n';
					oText.value += "海拔："+position.coords.altitude+ '\n';
					oText.value += "时间："+new Date(position.timestamp);
				},function(error){
					//查看定位失败的编码
					alert(error.code);
				},{
					//参数信息
					enableHighAcuracy:false,  //精确度
					//timeout:30000,   //超时的时间
					maximumAge:1000 //缓存时间
				});
	
				//多次请求			watchPosition
				timer = navigator.geolocation.watchPosition(function(position){
					oText.value += "经度："+position.coords.longitude + '\n';
					oText.value +="纬度："+ position.coords.latitude + '\n';
					oText.value += "海拔："+position.coords.altitude+ '\n';
					oText.value += "时间："+new Date(position.timestamp);
				},function(error){
					//查看定位失败的编码
					alert(error.code);
					//请求失败的时候，不再请求定位
					navigator.geolocation.clearWatch(timer);

				},{
					//参数信息
					enableHighAcuracy:false,  //精确度
					//timeout:30000,   //超时的时间
					maximumAge:1000, //缓存时间
					frequency:1000   //请求的频率
				});
		
	本地存储
		Storage
			sessionStorage
				session临时回话，从页面打开到页面关闭的时间段
				窗口的临时存储，页面关闭，本地存储消失
			localStorage
				永久存储（可以手动删除数据）
			特点
				存储量限制 ( 5M )
				客户端完成，不会请求服务器处理
				sessionStorage数据是不共享、 localStorage共享

		Storage API
			setItem():
				设置数据，key\value类型，类型都是字符串
				可以用获取属性的形式操作
			getItem():
				获取数据，通过key来获取到相应的value
			removeItem():
				删除数据，通过key来删除相应的value
			clear():
				删除全部存储的值

		存储事件:		必须在放到服务上才能有效
			当数据有修改或删除的情况下，就会触发storage事件
			在对数据进行改变的窗口对象上是不会触发的
			Key:设置或删除的key值，如果调用clear(),key为null
			newValue:新设置的值，如果调用removeStorage(),key为null
			oldValue:调用改变前的value值
			storageArea:当前的storage对象
			url:触发该脚本变化的文档的url
	
		例:	var aBtn = document.getElementsByTagName('input');
			aBtn[0].onclick= function(){
				alert('保存数据成功');
				//临时保存--保存页面开始到页面关闭的时间
				//window.sessionStorage.setItem('text',aBtn[2].value);
				//永久存储
				window.localStorage.setItem('text',aBtn[2].value);
			}
			
			//获取数据
			aBtn[1].onclick = function(){
				//alert(window.sessionStorage.getItem('text'));
				alert(window.localStorage.getItem('text'));
			}
			
			//删除数据
			aBtn[3].onclick = function(){
				//通过key删除数据
				//window.localStorage.removeItem('text');
				//通过clear删除
				window.localStorage.clear();
				alert('您已经删除数据');
			}
	
			//添加storage事件		必须在放到服务上才能有效
			window.addEventListener('storage',function(ev){
				console.log(ev.key); //key值
				console.log(ev.newValue); //新的值
				console.log(ev.oldValue);//旧的值
				console.log(ev.url); //触发改变的url
			});
	
	applicationCache离线应用程序		不懂
		离线应用是什么？
			乘坐飞机、手机信号弱、去演讲的时候，可能没有网络，这个时候就可以采用离线应用。
			离线存储如何工作的？

		离线存储的好处？
			没网的时候，可以正常访问
			快速响应页面，不必用多个HTTP占用资源带宽
			缓存的可以是任何文件

		搭建离线应用程序
			①服务器设置头信息 : 
				AddType text/cache-manifest .manifest
			② html标签加 : 
				manifest=“xxxxx.manifest”
			③写manifest文件 :  离线的清单列表
				先写 :  CACHE MANIFEST
				FALLBACK :  第一个网络地址没获取到，就走第二个缓存的
				NETWORK ：无论缓存中存在与否，均从网络获取
	
	https://html.spec.whatwg.org/multipage/workers.html#shared-workers-and-the-sharedworkerglobalscope-interface:handler-sharedworkerglobalscope-onconnect
	Web  Workers  单页面线程
		什么是worker?
			JS的单线程（放入UI队列的个数，利用定时器解决）
			可以让web应用程序具备后台处理能力，对多线程的支持非常好。

		Worker API
			new Worker(‘后台处理的JS地址’)
			利用postMessage传输数据
			importScripts(‘导入其他JS文件’)

		Worker运行环境
			navgator:appName、appVersion、userAgent、platform
			location:所有属性都是只读的
			self:指向全局 worker 对象
			所有的ECMA对象，Object、Array、Date等
			XMLHttpRequest构造器
			setTimeout和setInterval方法
			close()方法，立刻停止worker运行
			importScripts方法

	Web  SharedWorker  共享线程
		线程 workers.js
			var nextName = 0;
			function getNextName() {
			  return nextName++;
			};
			var viewers = {};
			onconnect = function (event) {
				//当线程开启，每个页面会有对应的event.ports[0]（如果页面没有开启线程，不会有event.ports[0]），要保存下来。发送信息时，要循环发送，才能发送到每个页面。
				var name = getNextName();
				viewers[name] = { port: event.ports[0]};
				event.ports[0].onmessage = function(event){
			      	for (var viewer in viewers)
			        	viewers[viewer].port.postMessage(event.data);
				}
			};

		每个页面
			//判断浏览器是否支持
			if(typeof(SharedWorker)!=="undefined"){
				//判断是否创建
	            if(typeof(worker)=="undefined"){
	                worker = new SharedWorker('workers.js');

	                // 监听回调信息，处理业务
	                // worker.port.addEventListener('message',function(e){
	                //     console.log(e.data)
	                // },false);
	                
	                // 开启线程，发送信息。只有开启线程，才能进行共享。
	                // worker.port.start();
	                // worker.port.postMessage('txt ');
	            }
	        }



	File API
		File API在表单中的文件输入字段的基础上，又添加了一些直接访问文件信息的接口。
		H5在DOM中为文件输入元素添加了一个files集合，在通过文本输入字段选择了一或多个文件时，
		files集合中将包含一组File对象，每个File对象对应着一个文件。
		每个File对象都有下列只读属性：
									name: 本地文件系统的文件名
									size： 文件的字节大小
									type：字符串，文件的MIME类型。
									lastModifiedDate：字符串，文件上一次被修改的事件（只有chrome实现了这个属性）


		FlieReader类型实现的是一种异步文件读取机制。
		可以把FileReader想象成XMLHttpRequest，区别只是它读取的是文件，而不是远程服务器。
		为了读取文件中的数据，FileReader提供了如下几个方法：
														readAsText(file, encoding):以纯文本的形式读取文件，将读取到的文本保存在result属性中。
														readAsDataURL(file)：读取文件并将文件一数据URI的形式保存在result属性中
														readAsBinaryString(file)(已废弃)：读取文件并将一个字符串保存在result属性中，字符串中的每一个字符表示一字节
														readAsArrayBuffer(file)：读取文件并将一个包含文件内容的ArrayBuffer保存在result属性中。
		由于读取过程是异步的，因此FileReader也提供了几个事件。其中最有用的三个事件是progress、error和load，分别表示是否又读取了新数据，是否发生了错误以及是否读完了整个文件。
		

		做用:
			读取内容
			读取部分内容
			读取文件的32B内容
			读取拖放的文件
			对象URL:对象URL也被称为blob URL，指的是引用保存在File或Blob中数据的URL。使用对象URL的好处是可以不必把文件内容读取到JavaScript中而直接使用文件内容。为此，只要在需要文件内容的地方提供对象URL即可。要创建对象URL，可以使用window.URL.createObjectURL()方法，并传入File或Blob对象。
			这个方法在Chrome中的实现叫window.webkitURL.createObjectURL()，因此可以通过如下函数来消除命名的差异：
				function createObjectURL(blob){
				    if(window.URL){
				        return window.URL.createObjectURL(blob);
				    } else if (window.webkitURL) {
				        return window.webkitURL.createObjectURL(blob);
				    } else {
				        return null;
				    }
				}


		读取内容:
			<input type="file" id="ff" /> 		通过file上传文件

			例子:
			var ff = document.getElementById('ff');		//获取id
			ff.addEventListener('change',function(){	//创建change事件
				var files = this.files,		//获取文件的信息,以数组新式存放数据
					type = 'default',
					reader = new FileReader();		//FlieReader类型实现的是一种异步文件读取机制,通过这个来转化文件

				if(/image/.test(files[0].type)){	//判断文件是图片或者文本
					type = 'image';
					reader.readAsDataURL(files[0]);		//读取文件并将文件以数据URI的形式保存在result属性中
				}else{
					type = 'text';
					reader.readAsText(files[0]);	//以纯文本的形式读取文件，将读取到的文本保存在result属性中。
				}

				reader.onerror = function(){	//是否发生了错误
					console.log('出错 '+reader.error.code);
				}

				reader.onprogress = function(e){	//是否又读取了新数据
					if(event.lengthComputable){
						console.log('进展 '+ e.loaded + '/' + e.total);
					}
				}

				reader.onload = function(){		//是否读完了整个文件
					switch (type) {
						case 'image':
							console.log(reader.result)
							break;
						case 'text':
							console.log(reader.result)
							break;
					}
				}

			},false);

			把图片转换为路径
			var windowURL = window.URL || window.webkitURL;
			windowURL.createObjectURL(event.target.files[0]);

	history
		浏览器是通过window对象的history对象来对浏览器历史访问记录，从而可以实现前进和后退。
		history对象可以理解其保存了一个有序的列表对象，每个对象都代表了一个页面信息（包括页面的url等信息），注意当前页面也被保存在里面。

		这样就可以通过浏览器本身提供的前进和后退按钮来操作，
		也可以利用javascript调用history对象的
											back()
											forward()
											go()		方法来实现页面的切换。
	
		HTML5引入了:
			histtory.pushState()
				1）第一个参数是个js对象，可以放任何的内容，可以在onpostate事件中（后面介绍）获取到便于做相应的处理。
				2）第二个参数是个字符串，目前好像没有起作用，可以传个空串。
				3）第三个参数是个字符串，就是保存到history中的url。
				例: history.pushState({}, "newtitle","test1.html");


			history.replaceState()
				同样有三个参数。区别在于，replaceState()是用来修改history对象中记录的当前页面的信息，它不是新建一个记录。
				例: history.replaceState({}, "newtitle","test"+i+".html");	假设i持续改变，地址栏的url也会一直改变，但页面并没有改变。

			window.onpostate事件
				在这个事件进行逻辑处理
				假设当要改变某部分内容，先把内容备份，通过history.pushState()跳转另一个页。当点击浏览器的返回或前进时，根据判断进性重新赋值。
				window.addEventListener('popstate',function(){

				},false);

		使用步骤:
			1.创建数组或对象，用来保存当前页ajax的数据
				var storage_arr = [];
			2.改变当前页面的路径
				history.replaceState({}, "newtitle",$('.href').val()+"?qa=1");
			3.监听onpostate事件，进行逻辑处理
				window.addEventListener('popstate',function(data){
					//在这里把保存的数据根据当前路径，进行替换。
	            },false);
	
	图片懒加载/预加载
		http://www.w3school.com.cn/jsref/dom_obj_image.asp
		var _img = new Image();
		_img.src = '图片路径';
		_img.onload =function(){//加载成功回调}	
		_img.onerror =function(){//加载失败回调}	
		
		有兼容问题
		_img.decode()  返回一个Promise
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	