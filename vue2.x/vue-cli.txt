

http://blog.csdn.net/xidongdong1/article/details/78613654		Vue中一些需要注意的点（采坑）

http://blog.csdn.net/sinat_29412671/article/details/53690658
https://juejin.im/post/583d1fe00ce463006baca2fa?utm_source=gold_browser_extension#heading-6

技巧
	当前路由页刷新
		const data = this.$route;
		const fullPath = data.fullPath;
		const title = (data.meta && data.meta.title) || '';

		// 如果没有使用 keep-alive 缓存页面，这一步是不需要的
		for (const item of this.$route.matched) {
			if (item.path === this.$route.path) {
				// console.log(item.instances.default);
				item.instances.default.$destroy();
				break;
			}
		}

		this.$router.replace({
			name: 'reload'
		});
		this.$nextTick(() => {
			this.$router.replace({
				path: fullPath
			});
		});

Vue 构建单页应用


	1.使用vue-cli创建项目
	2.使用vue-router实现单页路由
	3.用vuex管理我们的数据流
	4.使用vue-resource请求我们的node服务端
	5.使用.vue文件进行组件化的开发

	基于webpack开发,简单介绍webpack:

		1.我们将会使用webpack去为我们的模块打包，预处理，热加载。如果你对webpack不熟悉，它就是可以帮助我们把多个js文件打包为1个入口文件，并且可以达到按需加载。这就意味着，我们不用担心由于使用太多的组件，导致了过多的HTTP请求，这是非常有益于产品体验的。但我们并不只是为了这个而使用webpack，我们需要用webpack去编译.vue文件，如果没有使用一个loader去转换我们.vue文件里的style、js和html，那么浏览器就无法识别。

		2.模块热加载是webpack的一个非常碉堡的特性，将会为我们的单页应用带来极大的便利。通常来说，当我们修改了代码刷新页面，那应用里的所有状态就都没有了。这对于开发一个单页应用来说是非常痛苦的，因为需要重新在跑一遍流程。如果有模块热加载，当你修改了代码，你的代码会直接修改，页面并不会刷新，所以状态也会被保留。
	
	vue的使用
		npm run build --report  查看打包后的文件大小分布

		vue-router	 			路由管理
		vuex 					管理我们的数据流(全局数据的意思)

		入口在根目录的 src->main.js

		v-bind:title="1"	简写：  :title="1"
		v-on:click="c"		简写：	@click="c"

   		Vue.use()
   			像vue的插件要通过Vue.use来绑定上去
   			参数必须是:
   			函数 或 对象(传对象会执行install函数，这时候把js绑定到vue里Vue.prototype.myjs = myjs)

		vue-router
			通过Vue.use绑定到vue上
			this.$route 可以获取当前的路径信息
			this.$router.push()			可以直接写字符串,也可以传对象(必须按this.$route的格式来)
						.back() 		后退,传-1,如	this.$router.back(-1);
						.replace()		改变当前路径,如 this.$router.replace(this.$route.path + '?go=true')
				
			例子：vue路由
				new Router({
					//所有的路径写在routes的数组里
					routes:[{
						path: '/',				//定义路径
						name: 'Index',			//这个组件的名
						component: Index,		//组件的内容
						children:[{				//该组件下的子组件
							path:'calendar',
						}]
					},{
						path: '/lists',
						name: 'Lists',
						component: Lists,
						children:[{
							path:'calendar',
						},{
							path: 'detail/:id',		//携带参数
							name: 'Detail',
							component: Detail,
							children:[{
								path:'calendar',
							},{
								path:'all_img',
							},{
								path:'more',
								name: 'DetailMore',
								component: DetailMore
							},{
								path: 'comment/:tk',
								component: Comment,
								children:[{
									path:'discuss'
								}]
							},{
								path:'s_order',
								component: SubmitOrder,
								children:[{
									path:'o_detail'
								}]
							}]
						}]
					}]
				})



		组件间通信
			1)this.$parent.(变量名或函数)
				this.$children.

			2)在父里<router-view
						:bianliang1="bianliang1"
						:bianliang2="bianliang2"
					/>
				在子里 props:['bianliang1','bianliang2'] 变成自己的

			3)在父里<router-view
						v-on:msg1="fun1"
						v-on:msg2="fun2"
					/>
				在子里 this.$emit('msg1','') 第一个是函数名，必须在父里v-on:msg1才能调用
											第二个是这函数需要的传参，没有可不填

			4)ref 和 $refs

	vue seo
		http://vuejs-templates.github.io/webpack/prerender.html

		1.npm install --save-dev prerender-spa-plugin

		2.在build / webpack.prod.conf.js中需要它：
			// 此行应位于其他“导入”所在文件的顶部
			const PrerenderSpaPlugin = require('prerender-spa-plugin')

		3.在plugins数组中配置它（也在build / webpack.prod.conf.js中）：
			new PrerenderSpaPlugin(
				// 已编译应用程序的路径
				path.join(__dirname, '../dist'),
				// 要预呈现的端点列表
				[ '/' ]
			)
			// 如果你也想预渲染/about和/contact，那么数组会[ '/', '/about', '/contact' ]。
		
		4.启用历史记录模式vue-router：
			const router = new VueRouter({
				mode: 'history',
				routes: [...]
			});

		5.服务端配置的路径有限制
		
			打包后文件名必需是 index.html

			http://www.demo.zz/ 		必需是这种路径
			http://www.demo.zz/dist/ 	这种路径不可以

			简单说就是不能有深层结构路径
	
	
	
	
	安装初始化步骤：
		1.安装node、npm，在创建vue-cli(确保你有node和npm)。

			npm是什么东东？npm其实是Node.js的包管理工具（package manager）。

			为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。

			其实npm已经在Node.js安装的时候顺带装好了。

			版本号查询 node -v
					   npm -v

	    2.全局安装vue-cli  // "version": "2.9.2",
			
	    	默认路径:C:\Users\xxx\AppData\Roaming\npm
	    	$ npm install -g vue-cli
	    	这样方便经常使用的的依赖

    	3.创建项目(p:vue创建项目.png)
    		$ vue init webpack vue-tutorial   'vue-tutorial'为项目名称
    			Project name ...
    			Project description(描述) ...
    			Author(作者) ...
    			Vue build(vue公司创建) ...
    			Use ESlint to lint your code?(ESlint语法规范检查工具) ...
    			Set up unit tests(设置单元测试) ...
    			Setup e2e tests with Nightwatch(单元测试不需要) ...

		4.进入项目根目录的控制台
			$ npm run dev 在热加载中运行应用
			默认路径是 http://localhost:8080 端口被占用，会自动更换
			更改路径可以在根目录的 config->index.js 里找到 host 进行更改

		5.发布项目
			https://www.cnblogs.com/qiu-Ann/p/7477593.html
			http://blog.csdn.net/liangxhblog/article/details/78866066
			http://bbs.csdn.net/topics/391984869
			打包好 $ npm run build 必须放到服务器上

			路径出错的话改根目录下:
				build->webpack.base.conf.js
					output:{ publicPath:'./' } 改output里的publicPath参数

			图片路径错误的话改根目录下:
				build->utils.js
					找到以下这部分
					// Extract CSS when that option is specified
    				// (which is the case during production build)
					{publicPath:'../../'} 加上这个
    				例子：if (options.extract) {
						      return ExtractTextPlugin.extract({
						        use: loaders,
						        fallback: 'vue-style-loader',
						~~~~~~~ publicPath:'../../'
						      })
						    } else {
						      return ['vue-style-loader'].concat(loaders)
						    }	
























































